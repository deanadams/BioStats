plotAllometry(fit, size = gdf$Csize, logsz = TRUE, method = "PredLine",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
# RegScore
plotAllometry(fit, size = gdf$Csize, logsz = TRUE, method = "RegScore",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
# Size-Shape PCA
pc.plot <- plotAllometry(fit, size = gdf$Csize, logsz = TRUE,
method = "size.shape",
pch = 19, col = as.numeric(interaction(gdf$species, gdf$site)))
summary(pc.plot$size.shape.PCA)
devtools::install_github('mlcolly/RRPP', ref="develop")
devtools::install_github('mlcollyer/RRPP', ref="develop")
library(RRPP)
library(rbenchmark)
install.packages("rbenchmark")
n <- 1000
p <- 10
iter <- 999
Y <- matrix(rnorm(n*p), n, p)
x1 <- rnorm(n)
x2 <- rnorm(n)
x3 <- rnorm(n)
x4 <- rnorm(n)
x5 <- rnorm(n)
library(rbenchmark)
form <- Y ~ x1 + x2 + x3 + x4 + x5
benchmark(lm.rrpp(form, iter = iter,
print.progress = FALSE,
Parallel = FALSE),
lm.rrpp(form, iter = iter,
print.progress = FALSE,
Parallel = TRUE),
lm.rrpp(form, iter = iter,
turbo = TRUE,
print.progress = FALSE,
Parallel = FALSE),
lm.rrpp(form, iter = iter,
turbo = TRUE,
print.progress = FALSE,
Parallel = TRUE),
replications=10, columns = c("test", "elapsed", "relative"))
RRPP:::box.cox
RRPP:::box.cox.fast
#Relative Eigenvalue Variance function
rel.eig.Var <- function(x, n) {
eigs <- eigen(cov(x))$values
eig <- lapply(1:length(eigs), function (i) {
(eigs[i]-1)^2
})
var <- (sum(unlist(eig)) / n) / (n-1)
var
}
#Bootstrap function for Relative Eigenvalue Variance
boot.VE <- function (x, p, hist = TRUE) {
#x = original dataset (mydat)
#p = desired number of subsampled traits for ICV calculation
library(rlist)
VEobs <- rel.eig.Var(x, p)
boot_dat <- RRPP:::boot.index(p, iter = 999, seed = "random")
VErand <- sapply(1:1000, function(j) {
boot.dat <- boot_dat[[j]]
data <- x[,boot.dat]
VE <- rel.eig.Var(data,p)
})
if (hist == TRUE ) {
plot <- hist(VErand)
segments(VEobs, 0, VEobs, 100, bg = "red")
}
else {
plot <- NA
}
pval <- length(which(abs(VErand)>=abs(VEobs))) / (1000+1)
eff.size <- (VEobs - mean(VErand)) / sd(VErand) #Should these be log transformed?
out <- list(VEobs = VEobs, Boot.dat = VErand, pvalue = pval, eff.size = eff.size)
plot
out
}
#Relative Eigenvalue Variance function
rel.eig.Var <- function(x, n) {
eigs <- eigen(cov(x))$values
eig <- lapply(1:length(eigs), function (i) {
(eigs[i]-1)^2
})
var <- (sum(unlist(eig)) / n) / (n-1)
var
}
y <- matrix(rnorm(10000),ncol=10)
nrow(y)
out <- rel.eig.Var(y,10
)
out
eigs <- eigen(cor(y))$values
sd(eigen(cor(y))$values)*9/10
#Relative Eigenvalue Variance function
rel.eig.Var <- function(x, n) {
eigs <- eigen(cor(x))$values
eig <- lapply(1:length(eigs), function (i) {
(eigs[i]-1)^2
})
var <- (sum(unlist(eig)) / n) / (n-1)
var
}
rel.eig.Var(y,10)
sd(eigen(cor(y))$values)*9/10
mean(eigen(cor(y))$values
mean(eigen(cor(y))$values)
sd(eigen(cor(y))$values)
sd(eigen(cor(y))$values)*9/10
mean(eigen(cor(y))$values)
x <- matrix(rnorm(10000),ncol=10)
rel.eig.Var(x,10)
sd(eigen(cor(x))$values)*9/10
mean(eigen(cor(x))$values)
eigs <- eigen(cor(x))$values
eig <- lapply(1:length(eigs), function (i) {
(eigs[i]-1)^2
})
eig
n=10
(sum(unlist(eig)) / n) / (n-1)
eigs
var(eigen(cor(x))$values)*9/10
rel.eig.Var(x,10)
vals <-eigen(cor(x))$values
vals
sum((vals-1)^2)
sum((vals-1)^2)/10
var(eigen(cor(x))$values)*9/10
#the simple way
var(vals)*9/10
(sum((vals-1)^2)/10
(sum((vals-1)^2)/10  / 9
sum((vals-1)^2)/10  / 9
rel.eig.Var(x,10)
#the simple way
var(vals)/10
x <- matrix(rnorm(10000),ncol=10)
rel.eig.Var(x,10)
vals <-eigen(cor(x))$values
mean(vals)
sum((vals-1)^2)/10  / 9
#the simple way
var(vals)/10
sum((vals-1)^2)/10  / 9
x <- matrix(rnorm(10000),ncol=10)
rel.eig.Var(x,10)
vals <-eigen(cor(x))$values
mean(vals)
#the simple way
var(vals)/10
x <- matrix(rnorm(10000),ncol=10)
rel.eig.Var(x,10)
#the simple way
var(vals)/10
x <- matrix(rnorm(10000),ncol=10)
rel.eig.Var(x,10)
vals <-eigen(cor(x))$values
#the simple way
var(vals)/10
x <- matrix(rnorm(10000),ncol=10)
rel.eig.Var(x,10)
#the simple way
var(eigen(cor(x))$values)/10
x <- seq(1:10)
x
y <- 0.9*x
y
coef(lm(y~x))
coef(lm(x~y))
1/.9
library(phytools)
tree <- pbtree(10,scale=1)
library(phytools)
tree <- pbtree(n = 10,scale=1)
names(x) <- names(y) <- tree$tip.label
library(RRPP)
C <-vcvPhylo(tree)
C
coef(lm.rrpp(y~x, Cov = C))
lm.rrpp(y~x, Cov = C, iter=0)
res <-lm.rrpp(y~x, Cov = C, iter=0)
res$LM$gls.coefficients
lm.rrpp(y~x, Cov = C, iter=0)$LM$gls.coefficients
lm.rrpp(x~y, Cov = C, iter=0)$LM$gls.coefficients
library(phytools)
library(RRPP)
tree <- pbtree(n = 10,scale=1)
x <- seq(1:10)
y <- 0.9*x
names(x) <- names(y) <- tree$tip.label
C <-vcvPhylo(tree)
## OLS
coef(lm(y~x))  #slope = 0.9
coef(lm(x~y))  # slope = 1.111  (= 1/0.9)
lm.rrpp(y~x, Cov = C, iter=0)$LM$gls.coefficients
lm.rrpp(x~y, Cov = C, iter=0)$LM$gls.coefficients
runif(10, -1, 1)
library(phytools)
library(RRPP)
tree <- pbtree(n = 10,scale=1)
x <- seq(1:10)
y <- 0.9*x
x <- seq(1:10) + runif(10, -1, 1)
y <- 0.9*x + runif(10, -1, 1)
names(x) <- names(y) <- tree$tip.label
C <-vcvPhylo(tree)
## OLS
coef(lm(y~x))  #slope = 0.9
coef(lm(x~y))  # slope = 1.111  (= 1/0.9)
1/.93196
1/0.9319610
lm.rrpp(y~x, Cov = C, iter=0)$LM$gls.coefficients
lm.rrpp(x~y, Cov = C, iter=0)$LM$gls.coefficients##
y <- rnorm(999)
y
bc1 <- RRPP:::box.cox(y)
y <- c(5, y)
y1.prime <- (y[1]^bc1$opt.lambda - 1)/bc1$opt.lambda
y.trans <- c(y1.prime, bc1$transformed)
bc2 <- RRPP:::box.cox(y)
RRPP:::effect.size(y.trans) # optimized without observed
RRPP:::effect.size(bc2$transformed) # optimized with observed
bc1
y <- rnorm(999)
hist(y)
bc1 <- RRPP:::box.cox(y)
hist(bc1$transformed)
y <- c(5, y)
hist(y)
y1.prime <- (y[1]^bc1$opt.lambda - 1)/bc1$opt.lambda
y1.prime
y.trans <- c(y1.prime, bc1$transformed)
y.trans
bc2 <- RRPP:::box.cox(y)
hist(bc2$transformed)
RRPP:::effect.size(y.trans) # optimized without observed
RRPP:::effect.size(bc2$transformed) # optimized with observed
RRPP:::box.cox.fast
library(geomorph)
?bilat.symmetry
data(lizards)
gdf <- geomorph.data.frame(shape = lizards$coords,
ind = lizards$ind,
replicate = lizards$rep)
liz.sym <- bilat.symmetry(A = shape, ind = ind, rep = rep,
object.sym = TRUE,
land.pairs = lizards$lm.pairs, data = gdf, RRPP = TRUE, iter = 149)
summary(liz.sym)
liz.sym <- bilat.symmetry(A = shape, ind = ind, rep = rep,
object.sym = TRUE,
land.pairs = lizards$lm.pairs, data = gdf, RRPP = TRUE, iter = 999)
summary(liz.sym)
library(geomorhp)
library(geomorph)
?bilat.symmetry
data(mosquito)
gdf <- geomorph.data.frame(wingshape = mosquito$wingshape,
ind=mosquito$ind,
side=mosquito$side,
replicate=mosquito$replicate)
mosquito.sym <- bilat.symmetry(A = wingshape, ind = ind, side = side,
replicate = replicate, object.sym = FALSE, RRPP = TRUE, iter = 149,
data = gdf)
summary(mosquito.sym)
mosquito.sym <- bilat.symmetry(A = wingshape, ind = ind, side = side,
replicate = replicate, object.sym = FALSE, RRPP = TRUE, iter = 999,
data = gdf)
summary(mosquito.sym)
plot(mosquito.sym, warpgrids = TRUE)
# Previous example, performing GPA first
Y.gpa <- gpagen(mosquito$wingshape)
mosquito.sym2 <- bilat.symmetry(A = Y.gpa, ind = ind, side = side,
replicate = replicate, object.sym = FALSE, RRPP = TRUE, iter = 999,
data = gdf)
summary(mosquito.sym2)
summary(mosquito.sym) # same results
data(lizards)
gdf <- geomorph.data.frame(shape = lizards$coords,
ind = lizards$ind,
replicate = lizards$rep)
liz.sym <- bilat.symmetry(A = shape, ind = ind, rep = rep,
object.sym = TRUE,
land.pairs = lizards$lm.pairs, data = gdf, RRPP = TRUE, iter = 999)
summary(liz.sym)
.23/.28
(.236788+.009432+.032119+.006283) / .284622
data(scallops)
gdf <- geomorph.data.frame(shape = scallops$coorddata,
ind = scallops$ind)
scallop.sym <- bilat.symmetry(A = shape, ind = ind,
object.sym = TRUE,
curves= scallops$curvslide, surfaces = scallops$surfslide,
land.pairs=scallops$land.pairs, data = gdf, RRPP = TRUE, iter = 999)
summary(scallop.sym)
(.236788+.009432+.032119) / .284622
?procD.lm
scallop.sym <- bilat.symmetry(A = shape, ind = ind, SS.type = "III"
object.sym = TRUE,
curves= scallops$curvslide, surfaces = scallops$surfslide,
land.pairs=scallops$land.pairs, data = gdf, RRPP = TRUE, iter = 999)
scallop.sym <- bilat.symmetry(A = shape, ind = ind, SS.type = "III",
object.sym = TRUE,
curves= scallops$curvslide, surfaces = scallops$surfslide,
land.pairs=scallops$land.pairs, data = gdf, RRPP = TRUE, iter = 999)
setwd("C:/DeanData/Teaching/EEOB590_AdvBiostat/BioStats/LabData")
setwd("C:/DeanData/Teaching/EEOB590_AdvBiostat/BioStats/LabData")
bumpus<-read.csv("Data/bumpus.csv",header=T)
bumpus.data<-as.matrix(bumpus[,(5:13)])  #note: 'as.matrix' forces data type
View(bumpus.data)
dim(bumpus.data)
pairs(bumpus.data)
cor(bumpus.data)    #correlation  matrix
dim()  cor(bumpus.data))    #correlation  matrix
dim(  cor(bumpus.data))    #correlation  matrix
vcv.bumpus<-var(bumpus.data)    #covariance matrix
var(bumpus.data)
a<-matrix(c(1,0,4,2,-1,1),nrow=3)
a
matrix(c(1,0,4,2,-1,1),nrow=3)
matrix(c(1,0,4,2,-1,1),nrow=3,byrow=T)
b<-matrix(c(1,-1,2,1,1,0),nrow=2)
a
b
c<-t(a)	#matrix transpose
a
c
d<-matrix(c(2,3,1,4),nrow=2)
d
det(d)	#matrix determinant
exp(determinant(d)$modulus)  #another way
det(var(bumpus.data))
var(bumpus.data)
a
b
c
#Matrix addition and subtraction
b+c
b-c
a+b		##NOTE: non-conformable matrices (check rxc of your matrices!)
a#elementwise multiplication (Hadamard product)
b
c
b
c*b
diag(5)  #identity matrix with 5 rows/cols
?diag
diag(10, 3, 4)
diag(10, 4, 4)
# matrix multiplication
a%*%b		## %*% is symbol for matrix multiplication
a
b
# matrix multiplication
a%*%b		## %*% is symbol for matrix multiplication
b%*%a		## matrix order matters
#__________________________________________________________________________#
# matrix inversion
d
solve(d)
d %*% solve(d)
solve(vcv.bumpus)
### example of redundant variables causing singularities
a <- rnorm(10)
b <-rnorm(10)
a
b
c <- a+b
cbind(a,b,c)
cov.dat <- cov(cbind(a,b,c))
cov.dat
solve(cov.dat)
det(cov.dat)
# Generalized Inverse
library(MASS)
ginv(vcv.bumpus)		#useful for singular covariance matrices (when P>N, or reduncancies in data)
ginv(cov.dat)
#__________________________________________________________________________#
### Matrix decomposition
#eigen-analysis
eigen(vcv.bumpus)			#decomposition of square-symmetric matrices
#singular-value decomposition
svd(vcv.bumpus)			#Same results as 'eigen'
#__________________________________________________________________________#
#GLM in matrix form
rm(list=ls())
x<-matrix(1,10)
x2<-matrix(c(1,1,1,1,1,0,0,0,0,0))
xnew<-cbind(x,x2)
y<-matrix(c(5,4,4,4,3,7,5,6,6,6))
yreg<-matrix(c(1,3,4,6,8,7,9,11,10,13))
xreg<-matrix(c(1,2,3,4,5,6,7,8,9,10))
xnewreg<-cbind(x,xreg)
x
x2
xnew
y
x2
#__________________________________________________________________________#
#ANOVA
model1<-lm(y~x2)
model1
model.matrix(model1)
xnew
summary(model1)
coef(model1)
b<-solve(t(xnew)%*%xnew)%*%t(xnew)%*%y
b
predict(model1)
yhat<-xnew%*%b
yhat
y-yhat
resid(model1)
SSFull<-t(y-yhat)%*%(y-yhat)
x
bred<-solve(t(x)%*%x)%*%t(x)%*%y
yhatred<-x%*%bred
yhatred
SSRed<-t(y-yhatred)%*%(y-yhatred) #Is SSTot
SSModel<-SSRed-SSFull
anova(model1)
SSModel
SSFull
SSRed
xreg
yreg
xnewreg
#__________________________________________________________________________#
#Regression
model2<-lm(yreg~xreg)
breg<-solve(t(xnewreg)%*%xnewreg)%*%t(xnewreg)%*%yreg
summary(model2)
breg
predict(model2)
yhatreg<-xnewreg%*%breg
yhatreg
SSFullreg<-t(yreg-yhatreg)%*%(yreg-yhatreg)
bredreg<-solve(t(x)%*%x)%*%t(x)%*%yreg
yhatredreg<-x%*%bredreg
yhatredreg
SSRedreg<-t(yreg-yhatredreg)%*%(yreg-yhatredreg) #Is SSTot
SSModelreg<-SSRedreg-SSFullreg
anova(model2)
SSModelreg
SSFullreg
SSRedreg
b
xnew
xnew%*%b
library(microbenchmark)
x<-matrix(rnorm(10000),ncol=2)
dim(x)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
dim(y)
lm(y~x)  #Common method
solve(t(xf)%*%xf)%*%t(xf)%*%y
crossprod(solve(crossprod(xf)),crossprod(xf,y))
lm.fit(xf,y)$coefficients
.lm.fit(xf,y)$coefficients  ### NOTE: a very low-level function (cannot use in packages submitted to CRAN)
qr.coef(qr(xf),y)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
###NOTE that the best implementation can change with the size of the data matrix
#Large X univ. Y
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
##Large Y univ. X
y<-matrix(rnorm(10000),ncol=100)
x<-matrix(rnorm(nrow(y)))
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#large Y and X
y<-matrix(rnorm(20000),ncol=100)
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#large Y and X
y<-matrix(rnorm(20000),ncol=100)
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)

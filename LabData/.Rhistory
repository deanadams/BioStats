#__________________________________________________________________________#
#single factor MANOVA
model1 <- lm(bumpus.data~sex)
summary(model1)	#yields a set of univariate analyses
anova(model1)
manova(model1)
summary(manova(model1))	#does multivariate test (using Pillai's)
summary(manova(model1),test="Wilks")	#does multivariate test (using Wilks)
?summary.manova
##### MANOVA via RRPP
model.rrpp <- lm.rrpp(Y~sex,data = mydat, print.progress = FALSE)
anova(model.rrpp)
plot(model.rrpp, type = "PC", pch=21, bg = sex)  #PC PLOT!
legend("topright", levels(sex), pch = 21, pt.bg = 1:4)
##When parametric methods break down
Ynew <- matrix(rnorm(10000), nrow=100) #100 x 100 matrix: N=p
dim(Ynew)
gp <- gl(2,50)
gp
lm(Ynew~gp)
summary(manova(lm(Ynew~gp)))  #parametric algebra cannot be completed
anova(lm.rrpp(Ynew~gp,print.progress = FALSE))  #NO problem with RRPP!
##When parametric methods break down
Ynew <- matrix(rnorm(100000), nrow=100) #100 x 100 matrix: N=p
dim(Ynew)
anova(lm.rrpp(Ynew~gp,print.progress = FALSE))  #NO problem with RRPP!
#__________________________________________________________________________#
#Factorial MANOVA
model2<-lm(bumpus.data~sex*surv)
summary(manova(model2))
#Factorial MANOVA via RRPP
model2.rrpp <- lm.rrpp(Y~sex*surv,data = mydat, print.progress = FALSE)
anova(model2.rrpp)
groups <- interaction(mydat$sex, mydat$surv)
plot(model2.rrpp, type = "PC", pch=21, bg = groups)
legend("topright", levels(groups), pch = 21, pt.bg = 1:4)
#Also in vegan (FRPP only)
adonis(formula = Y~sex*surv, method = "euclidean" )
anova(model2.rrpp)
#Pairwise comparisons
PW <- pairwise(model2.rrpp,groups = SexBySurv, print.progress = FALSE)
summary(PW,test.type = "dist")  #No pairwise groups significant AFTER accounting for main effects!
coef(model2.rrpp)
model.matrix(~sex*surv)
model.matrix(~sex*surv)%*%coef(model2.rrpp)
summary(pairwise(model2.rrpp, model.null, groups = SexBySurv,
print.progress = FALSE),test.type = "dist")
summary(PW,test.type = "dist")  #No pairwise groups significant AFTER accounting for main effects!
#__________________________________________________________________________#
### Multivariate Regression
summary(manova(lm(Y~TotalLength)))
model.reg <- lm.rrpp(Y~TotalLength, data = mydat, print.progress = FALSE)
anova(model.reg)
plot(TotalLength,Y[,1])
plot(TotalLength,Y[,2])
plot(TotalLength,Y[,3])
plot(TotalLength,Y[,4])
### Visualizing multivariate regression
plot(model.reg, type = "regression", reg.type = "RegScore",
predictor = mydat$TotalLength, pch=19)
coef(model.reg)
#__________________________________________________________________________#
#MANCOVA
summary(manova(lm(Y~TotalLength*sex*surv)))
summary(manova(lm(Y~TotalLength+sex*surv))) # FIT COMMON SLOPE
#MANCOVA via RRPP
model.mancova <- lm.rrpp(Y~TotalLength*sex*surv, data =mydat, print.progress = FALSE)
anova(model.mancova)
#MANCOVA via RRPP
model.mancova <- lm.rrpp(Y~TotalLength+sex*surv, data =mydat, print.progress = FALSE)
anova(model.mancova)
#MANCOVA via RRPP
model.mancova <- lm.rrpp(Y~TotalLength*sex*surv, data =mydat, print.progress = FALSE)
anova(model.mancova)
#Pairwise comparisons of slopes: NOTE: Used here for illustrative purposes only!
# Interaction should show evidence justifying this analysis
PW.mancova <- pairwise(model.mancova, groups = SexBySurv, covariate = TotalLength, print.progress = FALSE)
summary(PW.mancova, test.type = "VC", angle.type = "deg")
### Visualizing MANCOVA
plot(model.mancova, type = "regression", reg.type = "RegScore",
predictor = mydat$TotalLength, pch=19, col = as.numeric(groups))
plot(model.mancova, type = "regression", reg.type = "PredLine",
predictor = mydat$TotalLength, pch=19,
col = as.numeric(groups))
#________________________________________________________________________#
# A more complex example
data(Pupfish)
Pupfish$Group <- interaction(Pupfish$Sex, Pupfish$Pop)
dim(coords)
dim(Pupfish$coords)
#MANOVA via RRPP
fit.m <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.m)$table
summary(pairwise(fit.m,groups = Pupfish$Group),test.type = "dist")
#________________________________________________________________________#
#MANCOVA with Y as Distance matrix
mydat$Ydist <- dist(Y)
mancova.dist <- lm.rrpp (Ydist~TotalLength*sex*surv, data =mydat, print.progress = FALSE)
anova(mancova.dist)
#####  Interaction Term exploration: Trajectory Analysis
#Packages: RRPP
library(RRPP)
Pupfish$Group <- interaction(Pupfish$Sex, Pupfish$Pop)
#Pairwise comparisons from MANOVA
data(Pupfish)
fit.m <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.m)$table
summary(pairwise(fit.m,groups = Pupfish$Group))
plot(fit.m, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#####  Interaction Term exploration: Trajectory Analysis
#Packages: RRPP
library(RRPP)
#Pairwise comparisons from MANOVA
data(Pupfish)
Pupfish$Group <- interaction(Pupfish$Sex, Pupfish$Pop)
fit.m <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.m)$table
summary(pairwise(fit.m,groups = Pupfish$Group))
plot(fit.m, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Pairwise group comparisons while accounting for a covariate
Pupfish$logSize <- log(Pupfish$CS)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
PWS.gp <- pairwise(fit.slopes, groups = Pupfish$Group)
summary(PWS.gp)
plot(fit.slopes, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Comparison of slopes and lengths in MANCOVA
PWS <- pairwise(fit.slopes, groups = Pupfish$Group, covariate = Pupfish$logSize)
summary(PWS)
summary(PWS, test.type = "VC", angle.type = "deg")
plot(fit.slopes, type = "regression", reg.type = "RegScore", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
plot(fit.slopes, type = "regression", reg.type = "PredLine", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
##### Trajectory Analysis
#1: Estimate trajectories from LS means in factorial mode
fit <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 999)
plot(fit.slopes, type = "regression", reg.type = "PredLine", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
##### Trajectory Analysis
#1: Estimate trajectories from LS means in factorial mode
fit <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 999)
TA <- trajectory.analysis(fit, groups = Pupfish$Pop,
traj.pts = Pupfish$Sex, print.progress = FALSE)
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Plot results
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 1, col = "black")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
#2: Compare groups of pre-existing trajectories
data(motionpaths)
fit <- lm.rrpp(trajectories ~ groups, data = motionpaths, iter = 999)
TA <- trajectory.analysis(fit, groups = motionpaths$groups, traj.pts = 5)
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Shape differences between trajectories
summary(TA, attribute = "SD")
TP <- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)
############ let us begin with a comparison of implementations
mymean<-function(x){
n<-length(x)
tmp<-0
for (i in 1:n){
tmp<-tmp+x[i]
}
mn<-tmp/n
return(mn)
}
x<-matrix(rnorm(1000))
n<-length(x)
library(microbenchmark)
library(ggplot2)
microbenchmark(mean(x),apply(x,2,mean), sum(x)/length(x),mymean(x),colSums(x)/length(x))
############ Evaluating choke-points in code
#Example
library(aprof)
source("07-pls.slow.r")
tmp<-tempfile() #create tmp file for saving profiler output
Rprof(tmp,line.profiling=TRUE)  #profile the function
x<-matrix(rnorm(1000),ncol=10)
y<-matrix(rnorm(1000),ncol=10)
pls.slow(x,y)
Rprof(append=FALSE)
fooaprof<-aprof("07-pls.slow.r",tmp) #Create aprof object
plot(fooaprof)
iter<-99
SS<-array(NA,iter) #pre-allocate
newSS<-function(iter){ #'on the fly'
SS<-NULL
for (i in 1:iter){SS<-rbind(SS,NA)}
return(SS)
}
microbenchmark(SS<-array(NA,99), x<-newSS(99))
microbenchmark(SS<-array(NA,9999), x<-newSS(9999),times=10)
x<-cbind(1,matrix(rnorm(1000),ncol=10))
y<-matrix(rnorm(100))
all.calc<-function(x,y){
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-solve(t(x)%*%x)%*%t(x)%*%y.r
}
}
hat.calc<-function(x,y){
hat<-solve(t(x)%*%x)%*%t(x)
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-hat%*%y.r
}
}
microbenchmark(all.calc(x,y),hat.calc(x,y),times=10)
#3:  Use lower-level functions
x<-matrix(rnorm(10000),ncol=2)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
lm(y~x)  #Common method
solve(t(xf)%*%xf)%*%t(xf)%*%y
crossprod(solve(crossprod(xf)),crossprod(xf,y))
lm.fit(xf,y)$coefficients
.lm.fit(xf,y)$coefficients  ### NOTE: a very low-level function (cannot use in packages submitted to CRAN)
qr.coef(qr(xf),y)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
###NOTE that the best implementation can change with the size of the data matrix
#Large X univ. Y
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
x<-matrix(rnorm(nrow(y)))
xf<-cbind(1,x)
##Large Y univ. X
y<-matrix(rnorm(10000),ncol=100)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#large Y and X
y<-matrix(rnorm(20000),ncol=100)
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#4: Vectorize when possible. Don't speak R with a 'C accent'
fn1<-function(x){
means<-array(0,ncol(x))
for(i in 1:ncol(x)){
for(j in 1:nrow(x)){
means[i]<-means[i]+x[j,i]
}
}
means<-means/nrow(x)
return(means)
}
x<-matrix(rnorm(1000*1000),ncol=1000)
microbenchmark(fn1(x),colMeans(x),apply(x,2,mean),times=10)
###
x <- matrix(rnorm(1000*10000), ncol=1000)
fn1<-function(x){
mx <- rep(NA, nrow(x))
for(i in 1:nrow(x)){ mx[i] <- max(x[i,])  }
return(mx)
}
microbenchmark(fn1(x),apply(x,1,max),times=10)  #loop is faster here
#####  Interaction Term exploration: Trajectory Analysis
#Packages: RRPP
library(RRPP)
#Pairwise comparisons from MANOVA
data(Pupfish)
force(Pupfish)
dim(Pupfish$coords)
Pupfish$Group <- interaction(Pupfish$Sex, Pupfish$Pop)
Pupfish$Group
fit.m <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.m)$table
summary(pairwise(fit.m,groups = Pupfish$Group))
plot(fit.m, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Pairwise group comparisons while accounting for a covariate
Pupfish$logSize <- log(Pupfish$CS)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
PWS.gp <- pairwise(fit.slopes, groups = Pupfish$Group)
summary(PWS.gp)
fit.slopes <- lm.rrpp(coords ~ logSize + Pop * Sex, data = Pupfish, print.progress = FALSE)
PWS.gp <- pairwise(fit.slopes, groups = Pupfish$Group)
summary(PWS.gp)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
plot(fit.slopes, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Comparison of slopes and lengths in MANCOVA
PWS <- pairwise(fit.slopes, groups = Pupfish$Group, covariate = Pupfish$logSize)
summary(PWS)
summary(PWS, test.type = "VC", angle.type = "deg")
plot(fit.slopes, type = "regression", reg.type = "RegScore", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
plot(fit.slopes, type = "regression", reg.type = "PredLine", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
##### Trajectory Analysis
#1: Estimate trajectories from LS means in factorial mode
fit <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 999)
TA <- trajectory.analysis(fit, groups = Pupfish$Pop,
traj.pts = Pupfish$Sex, print.progress = FALSE)
TA$LS.means
TA$LS.means[[1]]
TA$MD
TA$MD[[1]]
TA$TC[[1]]
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Plot results
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 1, col = "black")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
#2: Compare groups of pre-existing trajectories
data(motionpaths)
motionpaths
fit <- lm.rrpp(trajectories ~ groups, data = motionpaths, iter = 999)
TA <- trajectory.analysis(fit, groups = motionpaths$groups, traj.pts = 5)
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Shape differences between trajectories
summary(TA, attribute = "SD")
TP <- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)
TP <- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
fit2 <- lm.rrpp(coords ~ logSize + Pop * Sex + logsize:Pop + logsize:Sex,
data = Pupfish, print.progress = FALSE)
fit2 <- lm.rrpp(coords ~ logSize + Pop * Sex + logSize:Pop + logSize:Sex,
data = Pupfish, print.progress = FALSE)
anova(fit2)
fit2 <- lm.rrpp(coords ~ logSize + Pop * Sex + logSize:Sex,
data = Pupfish, print.progress = FALSE)
anova(fit2)
plot(fit2, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Comparison of slopes and lengths in MANCOVA
PWS <- pairwise(fit2, groups = Pupfish$Group, covariate = Pupfish$logSize)
summary(PWS)
summary(PWS, test.type = "VC", angle.type = "deg")
############ let us begin with a comparison of implementations
mymean<-function(x){
n<-length(x)
tmp<-0
for (i in 1:n){
tmp<-tmp+x[i]
}
mn<-tmp/n
return(mn)
}
x<-matrix(rnorm(1000))
n<-length(x)
library(microbenchmark)
library(ggplot2)
length(x)
microbenchmark(mean(x),apply(x,2,mean), sum(x)/length(x),mymean(x),colSums(x)/length(x))
############ Evaluating choke-points in code
#Example
library(aprof)
source("07-pls.slow.r")
tmp<-tempfile() #create tmp file for saving profiler output
Rprof(tmp,line.profiling=TRUE)  #profile the function
x<-matrix(rnorm(1000),ncol=10)
y<-matrix(rnorm(1000),ncol=10)
pls.slow(x,y)
Rprof(append=FALSE)
fooaprof<-aprof("07-pls.slow.r",tmp) #Create aprof object
plot(fooaprof)
iter<-99
SS<-array(NA,iter) #pre-allocate
newSS<-function(iter){ #'on the fly'
SS<-NULL
for (i in 1:iter){SS<-rbind(SS,NA)}
return(SS)
}
microbenchmark(SS<-array(NA,99), x<-newSS(99))
microbenchmark(SS<-array(NA,9999), x<-newSS(9999),times=10)
x<-cbind(1,matrix(rnorm(1000),ncol=10))
y<-matrix(rnorm(100))
x
y
all.calc<-function(x,y){
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-solve(t(x)%*%x)%*%t(x)%*%y.r
}
}
hat.calc<-function(x,y){
hat<-solve(t(x)%*%x)%*%t(x)
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-hat%*%y.r
}
}
microbenchmark(all.calc(x,y),hat.calc(x,y),times=10)
#3:  Use lower-level functions
x<-matrix(rnorm(10000),ncol=2)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
lm(y~x)  #Common method
solve(t(xf)%*%xf)%*%t(xf)%*%y
crossprod(solve(crossprod(xf)),crossprod(xf,y))
lm.fit(xf,y)$coefficients
.lm.fit(xf,y)$coefficients  ### NOTE: a very low-level function (cannot use in packages submitted to CRAN)
qr.coef(qr(xf),y)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
###NOTE that the best implementation can change with the size of the data matrix
#Large X univ. Y
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
x<-matrix(rnorm(nrow(y)))
xf<-cbind(1,x)
##Large Y univ. X
y<-matrix(rnorm(10000),ncol=100)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#large Y and X
y<-matrix(rnorm(20000),ncol=100)
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#4: Vectorize when possible. Don't speak R with a 'C accent'
fn1<-function(x){
means<-array(0,ncol(x))
for(i in 1:ncol(x)){
for(j in 1:nrow(x)){
means[i]<-means[i]+x[j,i]
}
}
means<-means/nrow(x)
return(means)
}
x<-matrix(rnorm(1000*1000),ncol=1000)
dim(x)
microbenchmark(fn1(x),colMeans(x),apply(x,2,mean),times=10)
#####PLS: compare new and old versions
source('07-pls.fast.r')
source('07-pls.slow.r')
x<-matrix(rnorm(10000),ncol=10)
y<-matrix(rnorm(20000),ncol=20)
dim(x)
dim(y)
microbenchmark(pls.slow(x,y),pls.fast(x,y),times=5)

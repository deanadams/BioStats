#Test for phylogenetic signal in shape
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
summary(PS.shape)
plot(PS.shape)
plot(PS.shape$PACA, phylo = TRUE)
PS.shape$K.by.p # Phylogenetic signal profile
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
plot(PS.size)
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
plot(PS.size)
PS.size <- physignal(A=two.d.array(Y.gpa$Csize),phy=plethspecies$phy,iter=999)
PS.shape <- physignal(A=two.d.array(Y.gpa$coords),phy=plethspecies$phy,iter=999)
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
load("C:/DeanData/Research/Programming/GeoMorphCode/Geomorph-Questions-Help/2021-03-Anc.BM-polyotomies/example.bin")
physignal(dt$sh, dt$phy)
physignal(dt$cs, dt$phy) # Doesn´t run because:
is.binary(dt$phy)
#now the geomorph examples
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
#Test for phylogenetic signal in shape
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
summary(PS.shape)
plot(PS.shape)
plot(PS.shape$PACA, phylo = TRUE)
PS.shape$K.by.p # Phylogenetic signal profile
#Test for phylogenetic signal in size
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
load("C:/DeanData/Research/Programming/GeoMorphCode/Geomorph-Questions-Help/2021-03-Anc.BM-polyotomies/example.bin")
physignal(dt$sh, dt$phy)
physignal(dt$cs, dt$phy) # Doesn´t run because:
#now the geomorph examples
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
#Test for phylogenetic signal in shape
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
summary(PS.shape)
plot(PS.shape)
plot(PS.shape$PACA, phylo = TRUE)
PS.shape$K.by.p # Phylogenetic signal profile
#Test for phylogenetic signal in size
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
library(lmkchk)
library(lmkCHK)
install.packages('lmkCHK')
library(lmkCHK)
?lmkCHK
LMK_PCA_plot
9338*12
883+760
library(phytools)
?phytools
library(geomorph)
?gpagen
setwd("C:/DeanData/Teaching/EEOB590_AdvBiostat/BioStats/LabData")
# Read data from Smith and Collyer 2008
snake<-read.csv("data/Lab-11-snake.csv",header=T)
View(snake)
site<-as.factor(snake[,1]);region<-as.factor(snake[,2]);sex<-as.factor(snake[,3])
svl<-snake[,4]; hs<-snake[,5] # hs= head size, calculated as centroid size from lm
Y<-as.matrix(snake[,-(1:5)])
hs.svl<-lm(hs~svl, model=T,x=T)
hs.sex<-lm(hs~sex, model=T,x=T)
hs.reg<-lm(hs~region, model=T,x=T)
hs.svl.reg<-lm(hs~svl + region, model=T,x=T)
hs.svl.by.reg<-lm(hs~svl*region, model=T,x=T)
hs.svl.sex<-lm(hs~svl + sex, model=T,x=T)
hs.svl.by.sex<-lm(hs~svl*sex, model=T,x=T)
hs.ancova<-lm(hs~svl + sex*region, model=T,x=T)
hs.full<-lm(hs~svl*sex*region, model=T,x=T)
View(hs.full)
hs.full
Y
dim(Y)
Y.svl<-lm(Y~svl, model=T,x=T)
Y.sex<-lm(Y~sex, model=T,x=T)
Y.reg<-lm(Y~region, model=T,x=T)
Y.svl.reg<-lm(Y~svl+region, model=T,x=T)
Y.svl.by.reg<-lm(Y~svl*region, model=T,x=T)
Y.svl.sex<-lm(Y~svl + sex, model=T,x=T)
Y.svl.by.sex<-lm(Y~svl*sex, model=T,x=T)
Y.mancova<-lm(Y~svl + sex*region, model=T,x=T)
Y.full<-lm(Y~svl*sex*region, model=T,x=T)
#1: Nested Model comparisons:  LRT
anova(hs.full)  #with type I (sequential SS), each term addition is an LRT
anova(hs.svl.reg)
anova(hs.svl,hs.svl.reg)
anova(hs.svl.reg,hs.full)
#Multivariate is the same
anova(Y.full)
anova(Y.svl.reg,Y.svl)
anova(Y.mancova,Y.svl.reg)  #NOTE: sex not an improvement of model
#2: AIC comparisons
aic.summary<-AIC(hs.svl,hs.sex,hs.reg,hs.svl.reg,hs.svl.by.reg,hs.svl.sex,hs.svl.by.sex,
hs.ancova,hs.full)
aic.summary  #smallest AIC is preferred model
#Model Averaging
c1<-exp(-.5*0)
c2<-exp(-.5*(AIC(hs.svl.by.reg)-AIC(hs.svl.reg)))
c1
c2
w1<-c1/(c1+c2)  #AIC weights
w2<-c2/(c1+c2)
w1
w2
beta1<-w1*(hs.svl.reg$coef)
beta2<-w2*(hs.svl.by.reg$coef)
beta.avg<-c((beta1[1]+beta2[1]),(beta1[2]+beta2[2]),(beta1[3]+beta2[3]),
(beta1[4]+beta2[4]),beta2[5],beta2[6])
beta.avg #model averaged coefficients
formula(hs.svl.by.reg)
terms(formula(hs.svl.by.reg))
#FIND AIC for averaged model (need likelihood and its parameters)
Terms<-terms(formula(hs.svl.by.reg))  #set up X matrix
X<-model.matrix(Terms)
X
resid<-hs-X%*%beta.avg
E<-t(resid)%*%resid  #Note: univariate, so this IS the det(E)
E
n<-nrow(resid); p<-1  #NOTE: p<-ncol(resid) for multivariate
k<-hs.svl.by.reg$rank # same as df in "AIC" except "AIC" adds one for variance
LLik<- (-2*((-.5*n*(log(E/n^p)+p))-(0.5*(n*log(2*pi)))))
pen<-2*(p*k+0.5*p*(p+1))
pen
AIC.mdl.avg<-LLik+pen
AIC(hs.svl.by.reg)
AIC(hs.svl.reg)
AIC.mdl.avg  #NOTE: AIC of average model is WORSE than the 2 input models
?AIC
#2b: Multivariate model comparison
AIC(Y.svl)  #Need multivariate equivalent (and with correct parameter penalty)
maic<-function(x,...){ # each x is a model
y<-resid(x)
E<-t(y)%*%y
d<-det(E)
if(length(E)>1) n<-nrow(y) else n<-length(y)
if(length(E)>1) p<-ncol(y) else p<-1
k<-x$rank # same as df in "AIC" except "AIC" adds one for variance
lh<-n*(log(d/n^p)+p)
LLik<- (-2*((-.5*n*(log(d/n^p)+p))-(0.5*(n*log(2*pi)))))
pen<-2*(p*k+0.5*p*(p+1))
m<-LLik+pen
maic<-c(k,m)
}
maic.svl<-maic(Y.svl)
maic.sex<-maic(Y.sex)
maic.reg<-maic(Y.reg)
maic.svl.reg<-maic(Y.svl.reg)
maic.svl.by.reg<-maic(Y.svl.by.reg)
maic.svl.sex<-maic(Y.svl.sex)
maic.svl.by.sex<-maic(Y.svl.by.sex)
maic.mancova<-maic(Y.mancova)
maic.full<-maic(Y.full)
rbind(maic.svl,maic.sex,maic.reg,maic.svl.reg,maic.svl.by.reg,maic.svl.sex,
maic.svl.by.sex,maic.mancova,maic.full)
# Note, maic simplifies to univariate
aic.svl<-maic(hs.svl)
aic.reg<-maic(hs.reg)
aic.svl.reg<-maic(hs.svl.reg)
aic.svl
AIC(hs.svl)
# compare maic to AIC
aic.reg[2]-aic.svl.reg[2] # using maic
AIC(hs.reg)-AIC(hs.svl.reg) # canned R AIC function
##3: Cross validation
x<-seq(1:10)
y<-c(2,2,3,4,4,7,7,7,8,8)
plot(x,y)
anova(lm(y~x))
#subsample, fit model, residuals for cross-validated data,
#variance across iterations
iter=1000
rep<-lapply(1:iter, function(j) sample(seq(1:10),5))
diff<-lapply(1:iter, function(j) setdiff(seq(1:10),rep[[j]]))
#full model
model.x<- lapply(1:iter, function(j) lm(y[rep[[j]]]~x[rep[[j]]]))
resid.y<-lapply(1:iter, function(j)  resid(model.x[[j]],newdata=data.frame(c(x[diff[[j]]]))))
ss.x<-unlist(lapply(1:iter, function(j) crossprod(resid.y[[j]])))
#reduced model
model.1<- lapply(1:iter, function(j) lm(y[rep[[j]]]~1))
resid.1<-lapply(1:iter, function(j)  resid(model.1[[j]],newdata=data.frame(c(x[diff[[j]]]))))
ss.1<-unlist(lapply(1:iter, function(j) crossprod(resid.1[[j]])))
c(mean(ss.1),var(ss.1))
c(mean(ss.x),var(ss.x))
library(spatstat)
library(RRPP)
library(vegan)
library(spdep)
library(gstat)
#1: Ripley's K
data(cells)
plot(cells)
plot(Kest(cells))   #shows K for various models: isotropic, poisson, etc.
?Kest
E<-envelope(cells,Kest,nsim=100,rank=2)
plot(E) # plot shows that observed are underdispersed at small spatial scales
# Generate Spatially Autocorrelated Data  (one could also read some in!)
set.seed(2345)
lat<-runif(50,0,5); long<-runif(50,0,5)
g<-cbind(lat,long)  #create an XY spatial grid
y <- sqrt(diag(g%*%t(g))) + rnorm(nrow(g))  #a spatially-autocorrelated variable
# Value is associated with distance from origin
t <- sample(rep(c(1,2),length(y)/2))  #2 ecological 'groups' constrained by spatial contingency
sc <- 0.0   #spatial contingency: 0->1
for(i in 1:length(y)){
z = scale(y,scale=sd(y))
crit = 1-sc
crit =c(-crit/2,crit/2)*3
if(z[i]<=min(crit)) t[i]=1
if(z[i]>=max(crit)) t[i]=2
}
plot(g, pch=21, bg=t, cex=y, asp=1, main="Species diversity proprotional to circle size
Color designates ecological type")
#2: Covariation of Geography and Data
mantel(dist(g), dist(y), permutations = 9999)  # Mantel association
mantel.partial(dist(t), dist(y), dist(g), permutations = 9999)  #3-way Mantel holding group constant
#3: Spatial Autocorrelation
W<-tri2nb(g) #weights with Delauney tesselation
moran.test(y,nb2listw(W))   #positive autocorrelation
#3b: Semivarigram
df <- data.frame(g,y)
coordinates(df) = ~g
res <- variogram(y~1,df)
plot(res, type = "b", main = "Variogram: y")
#Plot vs. Gaussian model
VarMdl <- vgm(psill=2, model="Gau", nugget=0.1, range=1)
plot(res, model=VarMdl)
#4: Account for Spatial Non-Independence
ols.fit <- lm(y~t, x=T)  #spatial proximity not considered
summary(ols.fit)
anova(ols.fit)
# GLS models with different spatial autocorrelation structure
# Warning!  False convergences possible
t <- as.factor(t)
geo=data.frame(g,t,y)
gls.fit.exp = gls(y~t, data=geo, correlation=corExp(form=~lat+long)) #exponential
gls.fit.gaus = gls(y~t, data=geo,  correlation=corGaus(form=~lat+long)) #gaussian
gls.fit.spher = gls(y~t, data=geo,  correlation=corSpher(form=~lat+long)) #spherical
gls.fit.lin = gls(y~t, data=geo,  correlation=corLin(form=~lat+long))
# look at coeffcients: VERY DIFFERENT when spatial non-independence considered
ols.fit
gls.fit.exp
gls.fit.gaus
gls.fit.spher
gls.fit.lin
# model comparisons
AIC(gls.fit.exp, gls.fit.gaus, gls.fit.lin) #Careful when y is multivariate, see Model Selection lecture
## Exponential decay of spatial dependence is best model
# Anova
anova(gls.fit.exp)
anova(gls.fit.gaus)
anova(gls.fit.spher)
anova(gls.fit.lin)
#  One could estimate spatial covariance matrix from distances via Gower's approach
spatCov <- function(x){
x <- as.matrix(x)
if(ncol(x) != 2) stop("Need two columns for lat long!")
d <- dist(x)
P <- cmdscale(d, 2)
tcrossprod(P)/(ncol(P) - 1)
}
spat.cov<-spatCov(g)
rdf <- rrpp.data.frame(g=g, y=y,t=t, spat.cov = spat.cov)
res <- lm.rrpp(y~t,Cov = spat.cov, data = rdf)
anova(res)
# Generate Spatially Autocorrelated Data  (one could also read some in!)
set.seed(2345)
lat<-runif(50,0,5); long<-runif(50,0,5)
g<-cbind(lat,long)  #create an XY spatial grid
y <- sqrt(diag(g%*%t(g))) + rnorm(nrow(g))  #a spatially-autocorrelated variable
# Value is associated with distance from origin
t <- sample(rep(c(1,2),length(y)/2))  #2 ecological 'groups' constrained by spatial contingency
sc <- 0.0   #spatial contingency: 0->1
for(i in 1:length(y)){
z = scale(y,scale=sd(y))
crit = 1-sc
crit =c(-crit/2,crit/2)*3
if(z[i]<=min(crit)) t[i]=1
if(z[i]>=max(crit)) t[i]=2
}
plot(g, pch=21, bg=t, cex=y, asp=1, main="Species diversity proprotional to circle size
Color designates ecological type")
#2: Covariation of Geography and Data
mantel(dist(g), dist(y), permutations = 9999)  # Mantel association
mantel.partial(dist(t), dist(y), dist(g), permutations = 9999)  #3-way Mantel holding group constant
#3: Spatial Autocorrelation
W<-tri2nb(g) #weights with Delauney tesselation
moran.test(y,nb2listw(W))   #positive autocorrelation
#3b: Semivarigram
df <- data.frame(g,y)
coordinates(df) = ~g
res <- variogram(y~1,df)
plot(res, type = "b", main = "Variogram: y")
#Plot vs. Gaussian model
VarMdl <- vgm(psill=2, model="Gau", nugget=0.1, range=1)
plot(res, model=VarMdl)
#4: Account for Spatial Non-Independence
ols.fit <- lm(y~t, x=T)  #spatial proximity not considered
summary(ols.fit)
anova(ols.fit)
# GLS models with different spatial autocorrelation structure
# Warning!  False convergences possible
t <- as.factor(t)
geo=data.frame(g,t,y)
gls.fit.exp = gls(y~t, data=geo, correlation=corExp(form=~lat+long)) #exponential
gls.fit.gaus = gls(y~t, data=geo,  correlation=corGaus(form=~lat+long)) #gaussian
gls.fit.spher = gls(y~t, data=geo,  correlation=corSpher(form=~lat+long)) #spherical
gls.fit.lin = gls(y~t, data=geo,  correlation=corLin(form=~lat+long))
# look at coeffcients: VERY DIFFERENT when spatial non-independence considered
ols.fit
gls.fit.exp
gls.fit.gaus
gls.fit.spher
gls.fit.lin
# model comparisons
AIC(gls.fit.exp, gls.fit.gaus, gls.fit.lin) #Careful when y is multivariate, see Model Selection lecture
## Exponential decay of spatial dependence is best model
# Anova
anova(gls.fit.exp)
anova(gls.fit.gaus)
anova(gls.fit.spher)
anova(gls.fit.lin)
#  One could estimate spatial covariance matrix from distances via Gower's approach
spatCov <- function(x){
x <- as.matrix(x)
if(ncol(x) != 2) stop("Need two columns for lat long!")
d <- dist(x)
P <- cmdscale(d, 2)
tcrossprod(P)/(ncol(P) - 1)
}
spat.cov<-spatCov(g)
rdf <- rrpp.data.frame(g=g, y=y,t=t, spat.cov = spat.cov)
res <- lm.rrpp(y~t,Cov = spat.cov, data = rdf)
anova(res)
# Generate Spatially Autocorrelated Data  (one could also read some in!)
#set.seed(2345)
lat<-runif(50,0,5); long<-runif(50,0,5)
g<-cbind(lat,long)  #create an XY spatial grid
y <- sqrt(diag(g%*%t(g))) + rnorm(nrow(g))  #a spatially-autocorrelated variable
# Value is associated with distance from origin
t <- sample(rep(c(1,2),length(y)/2))  #2 ecological 'groups' constrained by spatial contingency
sc <- 0.0   #spatial contingency: 0->1
for(i in 1:length(y)){
z = scale(y,scale=sd(y))
crit = 1-sc
crit =c(-crit/2,crit/2)*3
if(z[i]<=min(crit)) t[i]=1
if(z[i]>=max(crit)) t[i]=2
}
plot(g, pch=21, bg=t, cex=y, asp=1, main="Species diversity proprotional to circle size
Color designates ecological type")
#2: Covariation of Geography and Data
mantel(dist(g), dist(y), permutations = 9999)  # Mantel association
mantel.partial(dist(t), dist(y), dist(g), permutations = 9999)  #3-way Mantel holding group constant
#3: Spatial Autocorrelation
W<-tri2nb(g) #weights with Delauney tesselation
moran.test(y,nb2listw(W))   #positive autocorrelation
#3b: Semivarigram
df <- data.frame(g,y)
coordinates(df) = ~g
res <- variogram(y~1,df)
plot(res, type = "b", main = "Variogram: y")
#Plot vs. Gaussian model
VarMdl <- vgm(psill=2, model="Gau", nugget=0.1, range=1)
plot(res, model=VarMdl)
#4: Account for Spatial Non-Independence
ols.fit <- lm(y~t, x=T)  #spatial proximity not considered
summary(ols.fit)
anova(ols.fit)
# GLS models with different spatial autocorrelation structure
# Warning!  False convergences possible
t <- as.factor(t)
geo=data.frame(g,t,y)
gls.fit.exp = gls(y~t, data=geo, correlation=corExp(form=~lat+long)) #exponential
gls.fit.gaus = gls(y~t, data=geo,  correlation=corGaus(form=~lat+long)) #gaussian
gls.fit.spher = gls(y~t, data=geo,  correlation=corSpher(form=~lat+long)) #spherical
gls.fit.lin = gls(y~t, data=geo,  correlation=corLin(form=~lat+long))
# look at coeffcients: VERY DIFFERENT when spatial non-independence considered
ols.fit
gls.fit.exp
gls.fit.gaus
gls.fit.spher
gls.fit.lin
# model comparisons
AIC(gls.fit.exp, gls.fit.gaus, gls.fit.lin) #Careful when y is multivariate, see Model Selection lecture
## Exponential decay of spatial dependence is best model
# Anova
anova(gls.fit.exp)
anova(gls.fit.gaus)
anova(gls.fit.spher)
anova(gls.fit.lin)
#  One could estimate spatial covariance matrix from distances via Gower's approach
spatCov <- function(x){
x <- as.matrix(x)
if(ncol(x) != 2) stop("Need two columns for lat long!")
d <- dist(x)
P <- cmdscale(d, 2)
tcrossprod(P)/(ncol(P) - 1)
}
spat.cov<-spatCov(g)
rdf <- rrpp.data.frame(g=g, y=y,t=t, spat.cov = spat.cov)
res <- lm.rrpp(y~t,Cov = spat.cov, data = rdf)
anova(res)
mycor <- corMatrix(Initialize(corExp(1,form = ~lat+long),data=geo))
anova(lm.rrpp(y~t,Cov = mycor, data = geo))
library(spatstat)
library(RRPP)
library(vegan)
library(spdep)
library(gstat)
#1: Ripley's K
data(cells)
plot(cells)
plot(Kest(cells))   #shows K for various models: isotropic, poisson, etc.
E<-envelope(cells,Kest,nsim=100,rank=2)
plot(E) # plot shows that observed are underdispersed at small spatial scales
# Generate Spatially Autocorrelated Data  (one could also read some in!)
#set.seed(2345)
lat<-runif(50,0,5); long<-runif(50,0,5)
g<-cbind(lat,long)  #create an XY spatial grid
y <- sqrt(diag(g%*%t(g))) + rnorm(nrow(g))  #a spatially-autocorrelated variable
# Value is associated with distance from origin
t <- sample(rep(c(1,2),length(y)/2))  #2 ecological 'groups' constrained by spatial contingency
sc <- 0.0   #spatial contingency: 0->1
for(i in 1:length(y)){
z = scale(y,scale=sd(y))
crit = 1-sc
crit =c(-crit/2,crit/2)*3
if(z[i]<=min(crit)) t[i]=1
if(z[i]>=max(crit)) t[i]=2
}
plot(g, pch=21, bg=t, cex=y, asp=1, main="Species diversity proprotional to circle size
Color designates ecological type")
y
g
#2: Covariation of Geography and Data
mantel(dist(g), dist(y), permutations = 9999)  # Mantel association
#3: Spatial Autocorrelation
W<-tri2nb(g) #weights with Delauney tesselation
W
nb2listw(W)
moran.test(y,nb2listw(W))   #positive autocorrelation
#3b: Semivarigram
df <- data.frame(g,y)
coordinates(df) = ~g
res <- variogram(y~1,df)
plot(res, type = "b", main = "Variogram: y")
#Plot vs. Gaussian model
VarMdl <- vgm(psill=2, model="Gau", nugget=0.1, range=1)
plot(res, model=VarMdl)
t
#4: Account for Spatial Non-Independence
ols.fit <- lm(y~t, x=T)  #spatial proximity not considered
summary(ols.fit)
anova(ols.fit)
# GLS models with different spatial autocorrelation structure
# Warning!  False convergences possible
t <- as.factor(t)
geo=data.frame(g,t,y)
gls.fit.exp = gls(y~t, data=geo, correlation=corExp(form=~lat+long)) #exponential
gls.fit.gaus = gls(y~t, data=geo,  correlation=corGaus(form=~lat+long)) #gaussian
gls.fit.spher = gls(y~t, data=geo,  correlation=corSpher(form=~lat+long)) #spherical
gls.fit.lin = gls(y~t, data=geo,  correlation=corLin(form=~lat+long))
# look at coefficients: VERY DIFFERENT when spatial non-independence considered
ols.fit
gls.fit.exp
gls.fit.gaus
gls.fit.spher
gls.fit.lin
# model comparisons
AIC(gls.fit.exp, gls.fit.gaus, gls.fit.lin) #Careful when y is multivariate, see Model Selection lecture
## Exponential decay of spatial dependence is best model
# Anova
anova(gls.fit.exp)
#  One could estimate spatial covariance matrix from distances via Gower's approach
spatCov <- function(x){
x <- as.matrix(x)
if(ncol(x) != 2) stop("Need two columns for lat long!")
d <- dist(x)
P <- cmdscale(d, 2)
tcrossprod(P)/(ncol(P) - 1)
}
spat.cov<-spatCov(g)
spat.cov
rdf <- rrpp.data.frame(g=g, y=y,t=t, spat.cov = spat.cov)
res <- lm.rrpp(y~t,Cov = spat.cov, data = rdf)
anova(res)
mycor <- corMatrix(Initialize(corExp(1,form = ~lat+long),data=geo))
mycor
anova(lm.rrpp(y~t,Cov = mycor, data = geo))

data = gdf, iter = 999,
RRPP = TRUE, print.progress = FALSE) # randomize residuals
summary(fit1)
summary(fit2)
fit1$fitted
gp <-  interaction(gdf$species, gdf$site)
PW <- pairwise(fit.full, groups = gp, covariate = NULL)
gp <-  interaction(gdf$species, gdf$site)
PW <- pairwise(fit.1, groups = gp, covariate = NULL)
gp <-  interaction(gdf$species, gdf$site)
PW <- pairwise(fit1, groups = gp, covariate = NULL)
PW$
PW$LS.means
PW$LS.means[[1]]
96346*.15
21768/9
96346*.15
2600 + 22275
library(geomorph)
?readmulti.tps
?readmulti.nts
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE)
library(geomorph)
?gpagen
# Example 3: points, curves and surfaces
data(scallops)
# Using Procrustes Distance for sliding
Y.gpa <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
surfaces = scallops$surfslide)
# NOTE can summarize as: summary(Y.gpa)
# NOTE can plot as: plot(Y.gpa)
plot(Y.gpa)
devtools::install_github('geomorphR/geomorph',ref="Develop")
library(geomorph)
data("plethodon")
res <- gpagen(plethodon$land)
res <- gpagen(plethodon$land, Parallel = TRUE)
data(hummingbirds)
Y.gpa <- gpagen(hummingbirds$land, curves = hummingbirds$curvepts,approxBE = TRUE)
Y.gpa <- gpagen(hummingbirds$land, curves = hummingbirds$curvepts,approxBE = FALSE)
Y.gpa <- gpagen(hummingbirds$land, curves = hummingbirds$curvepts,approxBE = TRUE,
Parallel = TRUE)
data(scallops)
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop", force = TRUE)
library(geomorph)
data(scallops)
Y.gpa.f <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
surfaces = scallops$surfslide, approxBE = FALSE)
Y.gpa.a <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
surfaces = scallops$surfslide, approxBE = TRUE)
# Without curves
Y.gpa.f <- gpagen(A = scallops$coorddata,
surfaces = scallops$surfslide, approxBE = FALSE)
Y.gpa.a <- gpagen(A = scallops$coorddata,
surfaces = scallops$surfslide, approxBE = TRUE)
# Without surfaces (illsutrates that approxBE should be avoided for few LM)
Y.gpa.f <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
approxBE = FALSE)
Y.gpa.a <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
approxBE = TRUE)
system.time(Y.gpa1 <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
surfaces = scallops$surfslide, approxBE = FALSE, max.iter = 50))
system.time(Y.gpa2 <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
surfaces = scallops$surfslide, approxBE = TRUE, max.iter = 50))
system.time(Y.gpa3 <- gpagen(A = scallops$coorddata, curves = scallops$curvslide,
surfaces = scallops$surfslide, approxBE = FALSE, max.iter = 50,
Parallel = TRUE))
library(geomorph)
library(RRPP)
fast.solve <- RRPP:::fast.solve
sparse.solve <- function(X){
keep <- which(round(X, 12) != 0)
m <- sqrt(length(keep))
Y <- matrix(X[keep], m, m)
Xn <- array(0, dim(X))
Xn[keep] <- fast.solve(Y)
Xn
}
X <-  var(matrix(rnorm(100 *1000),, 1000))
isSymmetric(X)
a <- as.logical(round(runif(nrow(X))))
X[a, ] <- 0
X[, a] <- 0
Xinv1 <- fast.solve(X)
Xinv2 <- sparse.solve(X)
all.equal(Xinv1, Xinv2)
library(microbenchmark)
microbenchmark(fast.solve(X), sparse.solve(X), times = 5)
dim(X)
library(geomorph)
?gpagen
library(geomorph)
data(plethodon)
y <- gpagen(plethodon$land)
y$procD
install.packages("RRPP", "geomorph")
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE)
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(mvMORPH)
manova.gls
mvMORPH::.linearhypothesis.gls
mvMORPH:::.linearhypothesis.gls
library(geomorph)
library(mvMORPH)
data("plethodon")
shape <-gpagen(plethodon$land)$coords
library(phytools)
dim(shape)
phy <- pbtree(n=40,scale = 1)
plot(phy)
?mvMORPH
n=50
p=5
phy <- pbtree(n=n,scale = 1)
library(geiger)
diag(p)
phy <- pbtree(n=n,scale = 1)
y<- sim.char(phy=phy, par = diag(p),nsim = 1)[,,1]
y
x1 <-gl(2,25)
x1
x1 <-sample(gl(2,25))
x2 <- gl(2,25)
df <- list(y=y, x1=x1, x2=x2)
model1 <- mvgls(y~x1*x2, data=df, tree=phy, model="BM", method="LOO")
manova.gls(model1)
out <- manova.gls(model1)
out
manova.gls
.aov.mvgls.perm.I
mvMORPH:::.aov.mvgls.perm.I
model1
model1$residuals
mvMORPH:::.aov.mvgls.perm.I
mvgls
mvMORPH:::.mvGLS
manova.gls
mvMORPH:::.aov.mvgls.I
mvMORPH:::.aov.mvgls.perm.I
mvgls
mvMORPH:::.corrStr
library(geomorph)
?phylo.modul
?phylo.modularity
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE)
library(geomorph)
?combine.subsets
data("plethspecies")
dim(plethspecies$land)
new <- combine.subsets(plethspecies$land[1:5,,], plethspecies$land[6:11,,])
new
dimnames(plethspecies$land)[3]
dimnames(new)[3] <- dimnames(plethspecies$land)[3]
new <- combine.subsets(plethspecies$land[1:5,,], plethspecies$land[6:11,,])
dim(new)
class(new)
new$combined.set
new$coords
dimnames(new$coords)[3] <- dimnames(plethspecies$land)[3]
new$coords
library(Matrix)
subject <- factor(rep(1:5, each = 3))
X <- model.matrix(~ subject)
H <- X %*% solve(crossprod(X)) %*% t(X)
H
image(Matrix(round(H, 2)))
set.seed(2003)
Y <- matrix(rnorm(45), nrow = 15, ncol = 3)
X0 <- model.matrix(Y ~ 1)
H0 <- X0 %*% solve(crossprod(X0)) %*% t(X0)
image(Matrix(H0, sparse = TRUE))
H0
Q <- qr.Q(qr(X))
Q
image(Matrix(round(Q, 3)))
library(geomorph)
y <- matrix(rnorm(100000),ncol=500)
dim(y)
gl <- 2,250
gps <- gl(2,250)
gps
res <- modularity.test(y,gps)
plot(res)
library(geomorph)
?readland.tps
library(phytools)
?fastBM
fastBM
phytools:::simBM
phytools:::simBM
geiger:::sim.char
devtools::install_github('mlcollyer/RRPP', ref="develop")
install.packages('utf8')
install.packages("utf8")
install.packages("RcooArmadillo")
install.packages("RcppArmadillo")
devtools::install_github('mlcollyer/RRPP', ref="develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
870+750
?geomorph::gm.prcomp
22275-13000
12000
2100*12
2100*11
22275-13200
2100*4.5
22275-9450
13200+9450
2100*11
2100*11-12000
2100*4.5
library(SoundShape)
install.packages("SoundShape")
library(SoundShape)
?SoundShape
library(geomorph)
?gpagen
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE)
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE, force = TRUE)
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE, force = TRUE)
library(geomorph)
?gpagen
library(RRPP)
?lm.rrpp
?bibentry
library(SoundShape)
?hypo.surf
devtools::install_github()
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE)
library(RRPP)
?lm.rrpp
library(StereoMorph)
?StereoMorph
library(geomorph)
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
land.gps<-c("A","A","A","A","A","B","B","B","B","B","B")
Y <- two.d.array(Y.gpa$coords)
Y1 <- Y[,1:10]
Y2 <- Y[, -(1:10)]
integration.test(Y.gpa$coords, partition.gp = land.gps)
two.b.pls(Y2, Y1)
two.b.pls(Y1, Y2)
IT=integration.test(Y.gpa$coords, partition.gp = land.gps)
IT$random.r[1:10]
?two.b.pls
PLS21 <- two.b.pls(Y2, Y1)
PLS21$random.r[1:10]
PLS12 <- two.b.pls(Y1, Y2)
PLS12$random.r[1:10]
devtools::install_github('geomorphR/geomorph',ref="Develop", build_vignettes = TRUE)
library(geomorph)
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
land.gps<-c("A","A","A","A","A","B","B","B","B","B","B")
Y <- two.d.array(Y.gpa$coords)
Y1 <- Y[,1:10]
Y2 <- Y[, -(1:10)]
integration.test(Y.gpa$coords, partition.gp = land.gps)
two.b.pls(Y2, Y1)
two.b.pls(Y1, Y2)
IT=integration.test(Y.gpa$coords, partition.gp = land.gps)
IT$random.r[1:10]
2100*4.5
25*300
25*500
100*500
devtools::install_github('mlcollyer/RRPP', ref="develop")
install.packages('vctor')
install.packages('vctrs')
install.packages("vctrs")
install.packages("vctrs")
devtools::install_github('mlcollyer/RRPP', ref="develop")
library(geomorph)
data(plethodon)
data("plethspecies")
plot(plethspecies$phy)
library(phytools)
phy <- collapse.to.star(phy = plethspecies$phy, node = 10)
phy <- collapse.to.star(plethspecies$phy, node = 10)
plot(phy)
plot(plethspecies$phy)
nodelabels()
phy <- collapse.to.star(plethspecies$phy, node = 16)
plot(phy)
physignal(plethspecies$land,phy)
dim(plethspecies$land)
plethspecies$land[1,,]
plethspecies$land[1,1,]
physignal(plethspecies$land[1,1,],phy)
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE)
install.packages("C:/DeanData/Research/Programming/GeoMorphCode/CurrentBeta/Develop/geomorph_4.0.0.tar.gz", repos = NULL, type = "source")
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop", build_vignettes = TRUE)
library(geomorph)
?physignal
ata(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
#Test for phylogenetic signal in shape
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
summary(PS.shape)
plot(PS.shape)
plot(PS.shape$PACA, phylo = TRUE)
PS.shape$K.by.p # Phylogenetic signal profile
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
plot(PS.size)
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
devtools::install_github('geomorphR/geomorph', ref="Develop")
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
plot(PS.size)
PS.size <- physignal(A=two.d.array(Y.gpa$Csize),phy=plethspecies$phy,iter=999)
PS.shape <- physignal(A=two.d.array(Y.gpa$coords),phy=plethspecies$phy,iter=999)
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
load("C:/DeanData/Research/Programming/GeoMorphCode/Geomorph-Questions-Help/2021-03-Anc.BM-polyotomies/example.bin")
physignal(dt$sh, dt$phy)
physignal(dt$cs, dt$phy) # Doesn´t run because:
is.binary(dt$phy)
#now the geomorph examples
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
#Test for phylogenetic signal in shape
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
summary(PS.shape)
plot(PS.shape)
plot(PS.shape$PACA, phylo = TRUE)
PS.shape$K.by.p # Phylogenetic signal profile
#Test for phylogenetic signal in size
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
devtools::install_github('geomorphR/geomorph', ref="Develop")
library(geomorph)
load("C:/DeanData/Research/Programming/GeoMorphCode/Geomorph-Questions-Help/2021-03-Anc.BM-polyotomies/example.bin")
physignal(dt$sh, dt$phy)
physignal(dt$cs, dt$phy) # Doesn´t run because:
#now the geomorph examples
data(plethspecies)
Y.gpa<-gpagen(plethspecies$land)    #GPA-alignment
#Test for phylogenetic signal in shape
PS.shape <- physignal(A=Y.gpa$coords,phy=plethspecies$phy,iter=999)
summary(PS.shape)
plot(PS.shape)
plot(PS.shape$PACA, phylo = TRUE)
PS.shape$K.by.p # Phylogenetic signal profile
#Test for phylogenetic signal in size
PS.size <- physignal(A=Y.gpa$Csize,phy=plethspecies$phy,iter=999)
summary(PS.size)
library(lmkchk)
library(lmkCHK)
install.packages('lmkCHK')
library(lmkCHK)
?lmkCHK
LMK_PCA_plot
9338*12
883+760
library(phytools)
?phytools
library(geomorph)
?gpagen
setwd("C:/DeanData/Teaching/EEOB590_AdvBiostat/BioStats/LabData")
# Read data from Smith and Collyer 2008
snake<-read.csv("data/Lab-11-snake.csv",header=T)
View(snake)
site<-as.factor(snake[,1]);region<-as.factor(snake[,2]);sex<-as.factor(snake[,3])
svl<-snake[,4]; hs<-snake[,5] # hs= head size, calculated as centroid size from lm
Y<-as.matrix(snake[,-(1:5)])
hs.svl<-lm(hs~svl, model=T,x=T)
hs.sex<-lm(hs~sex, model=T,x=T)
hs.reg<-lm(hs~region, model=T,x=T)
hs.svl.reg<-lm(hs~svl + region, model=T,x=T)
hs.svl.by.reg<-lm(hs~svl*region, model=T,x=T)
hs.svl.sex<-lm(hs~svl + sex, model=T,x=T)
hs.svl.by.sex<-lm(hs~svl*sex, model=T,x=T)
hs.ancova<-lm(hs~svl + sex*region, model=T,x=T)
hs.full<-lm(hs~svl*sex*region, model=T,x=T)
View(hs.full)
hs.full
Y
dim(Y)
Y.svl<-lm(Y~svl, model=T,x=T)
Y.sex<-lm(Y~sex, model=T,x=T)
Y.reg<-lm(Y~region, model=T,x=T)
Y.svl.reg<-lm(Y~svl+region, model=T,x=T)
Y.svl.by.reg<-lm(Y~svl*region, model=T,x=T)
Y.svl.sex<-lm(Y~svl + sex, model=T,x=T)
Y.svl.by.sex<-lm(Y~svl*sex, model=T,x=T)
Y.mancova<-lm(Y~svl + sex*region, model=T,x=T)
Y.full<-lm(Y~svl*sex*region, model=T,x=T)
#1: Nested Model comparisons:  LRT
anova(hs.full)  #with type I (sequential SS), each term addition is an LRT
anova(hs.svl.reg)
anova(hs.svl,hs.svl.reg)
anova(hs.svl.reg,hs.full)
#Multivariate is the same
anova(Y.full)
anova(Y.svl.reg,Y.svl)
anova(Y.mancova,Y.svl.reg)  #NOTE: sex not an improvement of model
#2: AIC comparisons
aic.summary<-AIC(hs.svl,hs.sex,hs.reg,hs.svl.reg,hs.svl.by.reg,hs.svl.sex,hs.svl.by.sex,
hs.ancova,hs.full)
aic.summary  #smallest AIC is preferred model
#Model Averaging
c1<-exp(-.5*0)
c2<-exp(-.5*(AIC(hs.svl.by.reg)-AIC(hs.svl.reg)))
c1
c2
w1<-c1/(c1+c2)  #AIC weights
w2<-c2/(c1+c2)
w1
w2
beta1<-w1*(hs.svl.reg$coef)
beta2<-w2*(hs.svl.by.reg$coef)
beta.avg<-c((beta1[1]+beta2[1]),(beta1[2]+beta2[2]),(beta1[3]+beta2[3]),
(beta1[4]+beta2[4]),beta2[5],beta2[6])
beta.avg #model averaged coefficients
formula(hs.svl.by.reg)
terms(formula(hs.svl.by.reg))
#FIND AIC for averaged model (need likelihood and its parameters)
Terms<-terms(formula(hs.svl.by.reg))  #set up X matrix
X<-model.matrix(Terms)
X
resid<-hs-X%*%beta.avg
E<-t(resid)%*%resid  #Note: univariate, so this IS the det(E)
E
n<-nrow(resid); p<-1  #NOTE: p<-ncol(resid) for multivariate
k<-hs.svl.by.reg$rank # same as df in "AIC" except "AIC" adds one for variance
LLik<- (-2*((-.5*n*(log(E/n^p)+p))-(0.5*(n*log(2*pi)))))
pen<-2*(p*k+0.5*p*(p+1))
pen
AIC.mdl.avg<-LLik+pen
AIC(hs.svl.by.reg)
AIC(hs.svl.reg)
AIC.mdl.avg  #NOTE: AIC of average model is WORSE than the 2 input models
?AIC
#2b: Multivariate model comparison
AIC(Y.svl)  #Need multivariate equivalent (and with correct parameter penalty)
maic<-function(x,...){ # each x is a model
y<-resid(x)
E<-t(y)%*%y
d<-det(E)
if(length(E)>1) n<-nrow(y) else n<-length(y)
if(length(E)>1) p<-ncol(y) else p<-1
k<-x$rank # same as df in "AIC" except "AIC" adds one for variance
lh<-n*(log(d/n^p)+p)
LLik<- (-2*((-.5*n*(log(d/n^p)+p))-(0.5*(n*log(2*pi)))))
pen<-2*(p*k+0.5*p*(p+1))
m<-LLik+pen
maic<-c(k,m)
}
maic.svl<-maic(Y.svl)
maic.sex<-maic(Y.sex)
maic.reg<-maic(Y.reg)
maic.svl.reg<-maic(Y.svl.reg)
maic.svl.by.reg<-maic(Y.svl.by.reg)
maic.svl.sex<-maic(Y.svl.sex)
maic.svl.by.sex<-maic(Y.svl.by.sex)
maic.mancova<-maic(Y.mancova)
maic.full<-maic(Y.full)
rbind(maic.svl,maic.sex,maic.reg,maic.svl.reg,maic.svl.by.reg,maic.svl.sex,
maic.svl.by.sex,maic.mancova,maic.full)
# Note, maic simplifies to univariate
aic.svl<-maic(hs.svl)
aic.reg<-maic(hs.reg)
aic.svl.reg<-maic(hs.svl.reg)
aic.svl
AIC(hs.svl)
# compare maic to AIC
aic.reg[2]-aic.svl.reg[2] # using maic
AIC(hs.reg)-AIC(hs.svl.reg) # canned R AIC function
##3: Cross validation
x<-seq(1:10)
y<-c(2,2,3,4,4,7,7,7,8,8)
plot(x,y)
anova(lm(y~x))
#subsample, fit model, residuals for cross-validated data,
#variance across iterations
iter=1000
rep<-lapply(1:iter, function(j) sample(seq(1:10),5))
diff<-lapply(1:iter, function(j) setdiff(seq(1:10),rep[[j]]))
#full model
model.x<- lapply(1:iter, function(j) lm(y[rep[[j]]]~x[rep[[j]]]))
resid.y<-lapply(1:iter, function(j)  resid(model.x[[j]],newdata=data.frame(c(x[diff[[j]]]))))
ss.x<-unlist(lapply(1:iter, function(j) crossprod(resid.y[[j]])))
#reduced model
model.1<- lapply(1:iter, function(j) lm(y[rep[[j]]]~1))
resid.1<-lapply(1:iter, function(j)  resid(model.1[[j]],newdata=data.frame(c(x[diff[[j]]]))))
ss.1<-unlist(lapply(1:iter, function(j) crossprod(resid.1[[j]])))
c(mean(ss.1),var(ss.1))
c(mean(ss.x),var(ss.x))

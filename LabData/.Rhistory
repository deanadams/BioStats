plot(fit.m, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Pairwise group comparisons while accounting for a covariate
Pupfish$logSize <- log(Pupfish$CS)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
PWS.gp <- pairwise(fit.slopes, groups = Pupfish$Group)
summary(PWS.gp)
plot(fit.slopes, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Comparison of slopes and lengths in MANCOVA
PWS <- pairwise(fit.slopes, groups = Pupfish$Group, covariate = Pupfish$logSize)
summary(PWS)
summary(PWS, test.type = "VC", angle.type = "deg")
plot(fit.slopes, type = "regression", reg.type = "RegScore", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
plot(fit.slopes, type = "regression", reg.type = "PredLine", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
##### Trajectory Analysis
#1: Estimate trajectories from LS means in factorial mode
fit <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 999)
plot(fit.slopes, type = "regression", reg.type = "PredLine", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
##### Trajectory Analysis
#1: Estimate trajectories from LS means in factorial mode
fit <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 999)
TA <- trajectory.analysis(fit, groups = Pupfish$Pop,
traj.pts = Pupfish$Sex, print.progress = FALSE)
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Plot results
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 1, col = "black")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
#2: Compare groups of pre-existing trajectories
data(motionpaths)
fit <- lm.rrpp(trajectories ~ groups, data = motionpaths, iter = 999)
TA <- trajectory.analysis(fit, groups = motionpaths$groups, traj.pts = 5)
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Shape differences between trajectories
summary(TA, attribute = "SD")
TP <- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)
############ let us begin with a comparison of implementations
mymean<-function(x){
n<-length(x)
tmp<-0
for (i in 1:n){
tmp<-tmp+x[i]
}
mn<-tmp/n
return(mn)
}
x<-matrix(rnorm(1000))
n<-length(x)
library(microbenchmark)
library(ggplot2)
microbenchmark(mean(x),apply(x,2,mean), sum(x)/length(x),mymean(x),colSums(x)/length(x))
############ Evaluating choke-points in code
#Example
library(aprof)
source("07-pls.slow.r")
tmp<-tempfile() #create tmp file for saving profiler output
Rprof(tmp,line.profiling=TRUE)  #profile the function
x<-matrix(rnorm(1000),ncol=10)
y<-matrix(rnorm(1000),ncol=10)
pls.slow(x,y)
Rprof(append=FALSE)
fooaprof<-aprof("07-pls.slow.r",tmp) #Create aprof object
plot(fooaprof)
iter<-99
SS<-array(NA,iter) #pre-allocate
newSS<-function(iter){ #'on the fly'
SS<-NULL
for (i in 1:iter){SS<-rbind(SS,NA)}
return(SS)
}
microbenchmark(SS<-array(NA,99), x<-newSS(99))
microbenchmark(SS<-array(NA,9999), x<-newSS(9999),times=10)
x<-cbind(1,matrix(rnorm(1000),ncol=10))
y<-matrix(rnorm(100))
all.calc<-function(x,y){
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-solve(t(x)%*%x)%*%t(x)%*%y.r
}
}
hat.calc<-function(x,y){
hat<-solve(t(x)%*%x)%*%t(x)
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-hat%*%y.r
}
}
microbenchmark(all.calc(x,y),hat.calc(x,y),times=10)
#3:  Use lower-level functions
x<-matrix(rnorm(10000),ncol=2)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
lm(y~x)  #Common method
solve(t(xf)%*%xf)%*%t(xf)%*%y
crossprod(solve(crossprod(xf)),crossprod(xf,y))
lm.fit(xf,y)$coefficients
.lm.fit(xf,y)$coefficients  ### NOTE: a very low-level function (cannot use in packages submitted to CRAN)
qr.coef(qr(xf),y)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
###NOTE that the best implementation can change with the size of the data matrix
#Large X univ. Y
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
x<-matrix(rnorm(nrow(y)))
xf<-cbind(1,x)
##Large Y univ. X
y<-matrix(rnorm(10000),ncol=100)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#large Y and X
y<-matrix(rnorm(20000),ncol=100)
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#4: Vectorize when possible. Don't speak R with a 'C accent'
fn1<-function(x){
means<-array(0,ncol(x))
for(i in 1:ncol(x)){
for(j in 1:nrow(x)){
means[i]<-means[i]+x[j,i]
}
}
means<-means/nrow(x)
return(means)
}
x<-matrix(rnorm(1000*1000),ncol=1000)
microbenchmark(fn1(x),colMeans(x),apply(x,2,mean),times=10)
###
x <- matrix(rnorm(1000*10000), ncol=1000)
fn1<-function(x){
mx <- rep(NA, nrow(x))
for(i in 1:nrow(x)){ mx[i] <- max(x[i,])  }
return(mx)
}
microbenchmark(fn1(x),apply(x,1,max),times=10)  #loop is faster here
#####  Interaction Term exploration: Trajectory Analysis
#Packages: RRPP
library(RRPP)
#Pairwise comparisons from MANOVA
data(Pupfish)
force(Pupfish)
dim(Pupfish$coords)
Pupfish$Group <- interaction(Pupfish$Sex, Pupfish$Pop)
Pupfish$Group
fit.m <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.m)$table
summary(pairwise(fit.m,groups = Pupfish$Group))
plot(fit.m, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Pairwise group comparisons while accounting for a covariate
Pupfish$logSize <- log(Pupfish$CS)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
PWS.gp <- pairwise(fit.slopes, groups = Pupfish$Group)
summary(PWS.gp)
fit.slopes <- lm.rrpp(coords ~ logSize + Pop * Sex, data = Pupfish, print.progress = FALSE)
PWS.gp <- pairwise(fit.slopes, groups = Pupfish$Group)
summary(PWS.gp)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
plot(fit.slopes, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Comparison of slopes and lengths in MANCOVA
PWS <- pairwise(fit.slopes, groups = Pupfish$Group, covariate = Pupfish$logSize)
summary(PWS)
summary(PWS, test.type = "VC", angle.type = "deg")
plot(fit.slopes, type = "regression", reg.type = "RegScore", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
plot(fit.slopes, type = "regression", reg.type = "PredLine", pch=21, bg = Pupfish$Group, predictor = Pupfish$logSize, cex=2)
legend("topleft", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
##### Trajectory Analysis
#1: Estimate trajectories from LS means in factorial mode
fit <- lm.rrpp(coords ~ Pop * Sex, data = Pupfish, iter = 999)
TA <- trajectory.analysis(fit, groups = Pupfish$Pop,
traj.pts = Pupfish$Sex, print.progress = FALSE)
TA$LS.means
TA$LS.means[[1]]
TA$MD
TA$MD[[1]]
TA$TC[[1]]
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Plot results
TP <- plot(TA, pch = as.numeric(Pupfish$Pop) + 20, bg = as.numeric(Pupfish$Sex),
cex = 1, col = "black")
add.trajectories(TP, traj.pch = c(21, 22), start.bg = 1, end.bg = 2)
legend("topright", levels(Pupfish$Pop), pch =  c(21, 22), pt.bg = 1)
#2: Compare groups of pre-existing trajectories
data(motionpaths)
motionpaths
fit <- lm.rrpp(trajectories ~ groups, data = motionpaths, iter = 999)
TA <- trajectory.analysis(fit, groups = motionpaths$groups, traj.pts = 5)
# Magnitude difference (absolute difference between path distances)
summary(TA, attribute = "MD")
# Correlations (angles) between trajectories
summary(TA, attribute = "TC", angle.type = "deg")
# Shape differences between trajectories
summary(TA, attribute = "SD")
TP <- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)
TP <- plot(TA, pch = 21, bg = as.numeric(motionpaths$groups),
cex = 0.7, col = "gray")
add.trajectories(TP, traj.pch = 21, traj.bg = 1:4)
fit.slopes <- lm.rrpp(coords ~ logSize * Pop * Sex, data = Pupfish, print.progress = FALSE)
anova(fit.slopes)$table
fit2 <- lm.rrpp(coords ~ logSize + Pop * Sex + logsize:Pop + logsize:Sex,
data = Pupfish, print.progress = FALSE)
fit2 <- lm.rrpp(coords ~ logSize + Pop * Sex + logSize:Pop + logSize:Sex,
data = Pupfish, print.progress = FALSE)
anova(fit2)
fit2 <- lm.rrpp(coords ~ logSize + Pop * Sex + logSize:Sex,
data = Pupfish, print.progress = FALSE)
anova(fit2)
plot(fit2, type = "PC", pch=21, bg = Pupfish$Group, cex=2)
legend("topright", levels(Pupfish$Group), pch = 21, pt.bg = 1:4)
#Comparison of slopes and lengths in MANCOVA
PWS <- pairwise(fit2, groups = Pupfish$Group, covariate = Pupfish$logSize)
summary(PWS)
summary(PWS, test.type = "VC", angle.type = "deg")
############ let us begin with a comparison of implementations
mymean<-function(x){
n<-length(x)
tmp<-0
for (i in 1:n){
tmp<-tmp+x[i]
}
mn<-tmp/n
return(mn)
}
x<-matrix(rnorm(1000))
n<-length(x)
library(microbenchmark)
library(ggplot2)
length(x)
microbenchmark(mean(x),apply(x,2,mean), sum(x)/length(x),mymean(x),colSums(x)/length(x))
############ Evaluating choke-points in code
#Example
library(aprof)
source("07-pls.slow.r")
tmp<-tempfile() #create tmp file for saving profiler output
Rprof(tmp,line.profiling=TRUE)  #profile the function
x<-matrix(rnorm(1000),ncol=10)
y<-matrix(rnorm(1000),ncol=10)
pls.slow(x,y)
Rprof(append=FALSE)
fooaprof<-aprof("07-pls.slow.r",tmp) #Create aprof object
plot(fooaprof)
iter<-99
SS<-array(NA,iter) #pre-allocate
newSS<-function(iter){ #'on the fly'
SS<-NULL
for (i in 1:iter){SS<-rbind(SS,NA)}
return(SS)
}
microbenchmark(SS<-array(NA,99), x<-newSS(99))
microbenchmark(SS<-array(NA,9999), x<-newSS(9999),times=10)
x<-cbind(1,matrix(rnorm(1000),ncol=10))
y<-matrix(rnorm(100))
x
y
all.calc<-function(x,y){
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-solve(t(x)%*%x)%*%t(x)%*%y.r
}
}
hat.calc<-function(x,y){
hat<-solve(t(x)%*%x)%*%t(x)
coef.r<-array(NA,dim=c(999,ncol(x)))
for (i in 1:999){
y.r<-y[sample(nrow(y)),]
coef.r[i,]<-hat%*%y.r
}
}
microbenchmark(all.calc(x,y),hat.calc(x,y),times=10)
#3:  Use lower-level functions
x<-matrix(rnorm(10000),ncol=2)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
lm(y~x)  #Common method
solve(t(xf)%*%xf)%*%t(xf)%*%y
crossprod(solve(crossprod(xf)),crossprod(xf,y))
lm.fit(xf,y)$coefficients
.lm.fit(xf,y)$coefficients  ### NOTE: a very low-level function (cannot use in packages submitted to CRAN)
qr.coef(qr(xf),y)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
###NOTE that the best implementation can change with the size of the data matrix
#Large X univ. Y
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
x<-matrix(rnorm(nrow(y)))
xf<-cbind(1,x)
##Large Y univ. X
y<-matrix(rnorm(10000),ncol=100)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#large Y and X
y<-matrix(rnorm(20000),ncol=100)
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#4: Vectorize when possible. Don't speak R with a 'C accent'
fn1<-function(x){
means<-array(0,ncol(x))
for(i in 1:ncol(x)){
for(j in 1:nrow(x)){
means[i]<-means[i]+x[j,i]
}
}
means<-means/nrow(x)
return(means)
}
x<-matrix(rnorm(1000*1000),ncol=1000)
dim(x)
microbenchmark(fn1(x),colMeans(x),apply(x,2,mean),times=10)
#####PLS: compare new and old versions
source('07-pls.fast.r')
source('07-pls.slow.r')
x<-matrix(rnorm(10000),ncol=10)
y<-matrix(rnorm(20000),ncol=20)
dim(x)
dim(y)
microbenchmark(pls.slow(x,y),pls.fast(x,y),times=5)
########################
#	PCA: Principal Components Analysis
library(RRPP)
library(vegan)
bumpus<-read.csv("data/bumpus.csv",header=T)
Y<-bumpus[,5:12]
Y <- scale(Y, scale = FALSE) #center data
gp.bumpus <- as.factor(bumpus$sex)
pca.bumpus<-prcomp(Y)
summary(pca.bumpus)
PC.scores<-pca.bumpus$x
plot(PC.scores,xlab="PC I", ylab="PC II",asp=1,pch=21,bg=gp.bumpus,cex = 1.5)
### PCA via svd
svd.res<-svd(Y)
svd.res$d^2/sum(svd.res$d^2)   #same % variation per PC axis
pc.scores.svd<-svd.res$u%*%diag(svd.res$d)  #PCA scores
plot(pc.scores.svd,asp=1, pch=21,bg=gp.bumpus,cex = 1.5)
legend("topright", levels(gp.bumpus), pch = 21,pt.bg=1:2)
#### PCA "by hand" via eigen-analysis
vcv.bumpus<-var(Y)	#Calculate PC axes
pc.bumpus<-eigen(vcv.bumpus)
pc.bumpus$values/sum(pc.bumpus$values)   #same % variation per PC axis
pc.scores<-Y%*%pc.bumpus$vectors	#Projection
plot(pc.scores,xlab="PC I", ylab="PC II",asp=1,pch=21,bg=gp.bumpus,cex = 1.5)
plot(pc.scores.svd,asp=1, pch=21,bg=gp.bumpus,cex = 1.5)
legend("topright", levels(gp.bumpus), pch = 21,pt.bg=1:2)
###########################
# 	PCoA
bumpus.dist<-dist(Y)
PCoA<-cmdscale(bumpus.dist)   #from vegan
plot(PCoA,pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[1,],, PCoA[2,pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[1,],, PCoA[2],pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[,1],, PCoA[,2],pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[,1], PCoA[,2],pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(pc.scores.svd,asp=1, pch=21,bg=gp.bumpus,cex = 1.5)
setwd("C:/DeanData/Teaching/EEOB590_AdvBiostat/BioStats/LabData")
#Multivariate Association
library(geomorph)
library(vegan)
library(RRPP)
data(pupfish)
p1<-c(4,10:17, 39:56) #variables [landmarks] in Y1
Y1<-two.d.array(pupfish$coords[p1,,]) # head data as 2D matrix
Y2<-two.d.array(pupfish$coords[-p1,,]) # body data as 2D matrix
Group<-as.factor(paste(pupfish$Pop,pupfish$Sex))
cols <- rep(1, 56)
cols[p1] <- 2
plotAllSpecimens(pupfish$coords, mean = FALSE, plot.param=list(pt.bg = cols)) #to show the data
## 1: Mantel
mantel(dist(Y1),dist(Y2),permutations = 9999)
plot(dist(Y1),dist(Y2))
mantel.partial(dist(Y1),dist(Y2),dist(pupfish$CS))  #3-way Mantel
#2: RV coefficient
RV<-function(x,y,iter=999){
n<-nrow(x)
x<-scale(x,scale=FALSE); y<-scale(y,scale=FALSE)
ind <- c(list(1:n), (Map(function(x) sample.int(n, n), 1:iter)))
y.rand <- lapply(1:(iter+1), function(i) y[ind[[i]], ])
S11<-crossprod(x, x)/(n - 1)
S22<-crossprod(y, y)/(n - 1)
S12.r<-lapply(1:(iter+1), function(i) crossprod(x, y.rand[[i]])/(n - 1))
RV.r<-unlist(lapply(1:(iter+1), function(i) sum(diag(S12.r[[i]]%*%t(S12.r[[i]]))) /
sqrt(sum(diag(S11%*%S11)) * sum(diag(S22%*%S22)))))
p.val<- 1-(rank(RV.r)[1])/(iter+1)
p.val<-ifelse(p.val==0,1/(iter+1),p.val)
return(list(RV=RV.r[[1]],pvalue=p.val))
}
RV(Y1,Y2)
sqrt(RV(Y1,Y2)$RV)  #closer to a correlation
#3: PLS
pls.res<-two.b.pls(Y1,Y2)
summary(pls.res)
plot(pls.res)
# Read Data
mydata<-read.csv("data/Lab-10.Pupfish.csv",header=T)
species<-as.factor(mydata[,1]); sex<-as.factor(mydata[,2])
SL<-(mydata[,3]); Y<-as.matrix(mydata[,-(1:3)])
Group<-as.factor(paste(species,sex))
Y<-prcomp(Y)$x
rdf <- rrpp.data.frame(Y=Y, SL=SL, sex=sex, species=species)
col.gp<-rep("green",nrow(Y));   col.gp[which(species== 'FW')]<-"red"
shape.gp<-rep(21,nrow(Y));   shape.gp[which(sex== 'M')]<-22
plot(Y,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
## CVA
library(MASS)
lda.pupfish<-lda(Y,Group)
cva.pupfish<-predict(lda.pupfish,Y)
cv.scores<-cva.pupfish$x
plot(cv.scores,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
#1: equidistant groups are not represented as such
library(mvtnorm)
corr.val<-0.7
groups<-gl(3,50)
a<- rmvnorm(n=50,mean=c(-3.4,0),sigma=matrix(c(1,corr.val,corr.val,1),2,2))
b<- rmvnorm(n=50,mean=c(3.4,0),sigma=matrix(c(1,corr.val,corr.val,1),2,2))
c<- rmvnorm(n=50,mean=c(0,6),sigma=matrix(c(1,corr.val,corr.val,1),2,2))
orig.data<-rbind(a,b,c)
col.gp.r<-rep("black",nrow(orig.data)); col.gp.r[which(groups== '2')]<-"red"; col.gp.r[which(groups== '3')]<-"green"
plot(orig.data,pch=21,bg=col.gp.r,asp=1,cex=1.5)
ordiellipse(orig.data, groups,conf=0.95)
plot(predict(lda(orig.data,groups))$x,pch=21,bg=col.gp.r,asp=1,cex=1.5)
ordiellipse(predict(lda(orig.data,groups))$x, groups,conf=0.95)
#2: CVA can generate differences even when there are none.
data.rand<-matrix(rnorm(150*150),ncol=150)
plot(data.rand,pch=21,bg=col.gp.r,asp=1,cex=1.5)
plot(predict(lda(data.rand[,1:150],groups))$x,pch=21,bg=col.gp.r,asp=1,cex=1.5)
## RDA
plot(Y,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
pupfish.rda<-rda(Y~SL+species+sex+species:sex)
rda.scores<-predict(pupfish.rda)
plot(rda.scores,pch=shape.gp,bg=col.gp,asp=1,cex=1.5,xlab="RDA 1", ylab="RDA 2")
anova(lm.rrpp(Y~SL*species*sex, data=rdf, print.progress = FALSE))$table
##change X matrix, obtain distinct plots
plot(Y,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
plot(predict(rda(Y~SL*species*sex)),pch=shape.gp,
bg=col.gp,asp=1,cex=1.5,xlab="RDA 1", ylab="RDA 2")
plot(predict(rda(Y~species*sex)),pch=shape.gp,
bg=col.gp,asp=1,cex=1.5,xlab="RDA 1", ylab="RDA 2")

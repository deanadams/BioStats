qr.coef(qr(xf),y)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
###NOTE that the best implementation can change with the size of the data matrix
#Large X univ. Y
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
y<-matrix(rnorm(nrow(x)))
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
x<-matrix(rnorm(nrow(y)))
xf<-cbind(1,x)
##Large Y univ. X
y<-matrix(rnorm(10000),ncol=100)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#large Y and X
y<-matrix(rnorm(20000),ncol=100)
x<-matrix(rnorm(10000),ncol=50)
xf<-cbind(1,x)
microbenchmark(
lm(y~x),
solve(t(xf)%*%xf)%*%t(xf)%*%y,
crossprod(solve(crossprod(xf)),crossprod(xf,y)),
lm.fit(xf,y),.lm.fit(xf,y),
qr.coef(qr(xf),y)
)
#4: Vectorize when possible. Don't speak R with a 'C accent'
fn1<-function(x){
means<-array(0,ncol(x))
for(i in 1:ncol(x)){
for(j in 1:nrow(x)){
means[i]<-means[i]+x[j,i]
}
}
means<-means/nrow(x)
return(means)
}
x<-matrix(rnorm(1000*1000),ncol=1000)
dim(x)
microbenchmark(fn1(x),colMeans(x),apply(x,2,mean),times=10)
#####PLS: compare new and old versions
source('07-pls.fast.r')
source('07-pls.slow.r')
x<-matrix(rnorm(10000),ncol=10)
y<-matrix(rnorm(20000),ncol=20)
dim(x)
dim(y)
microbenchmark(pls.slow(x,y),pls.fast(x,y),times=5)
########################
#	PCA: Principal Components Analysis
library(RRPP)
library(vegan)
bumpus<-read.csv("data/bumpus.csv",header=T)
Y<-bumpus[,5:12]
Y <- scale(Y, scale = FALSE) #center data
gp.bumpus <- as.factor(bumpus$sex)
pca.bumpus<-prcomp(Y)
summary(pca.bumpus)
PC.scores<-pca.bumpus$x
plot(PC.scores,xlab="PC I", ylab="PC II",asp=1,pch=21,bg=gp.bumpus,cex = 1.5)
### PCA via svd
svd.res<-svd(Y)
svd.res$d^2/sum(svd.res$d^2)   #same % variation per PC axis
pc.scores.svd<-svd.res$u%*%diag(svd.res$d)  #PCA scores
plot(pc.scores.svd,asp=1, pch=21,bg=gp.bumpus,cex = 1.5)
legend("topright", levels(gp.bumpus), pch = 21,pt.bg=1:2)
#### PCA "by hand" via eigen-analysis
vcv.bumpus<-var(Y)	#Calculate PC axes
pc.bumpus<-eigen(vcv.bumpus)
pc.bumpus$values/sum(pc.bumpus$values)   #same % variation per PC axis
pc.scores<-Y%*%pc.bumpus$vectors	#Projection
plot(pc.scores,xlab="PC I", ylab="PC II",asp=1,pch=21,bg=gp.bumpus,cex = 1.5)
plot(pc.scores.svd,asp=1, pch=21,bg=gp.bumpus,cex = 1.5)
legend("topright", levels(gp.bumpus), pch = 21,pt.bg=1:2)
###########################
# 	PCoA
bumpus.dist<-dist(Y)
PCoA<-cmdscale(bumpus.dist)   #from vegan
plot(PCoA,pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[1,],, PCoA[2,pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[1,],, PCoA[2],pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[,1],, PCoA[,2],pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(-1*PCoA[,1], PCoA[,2],pch=21,bg=gp.bumpus,cex=1.5,asp=1)
plot(pc.scores.svd,asp=1, pch=21,bg=gp.bumpus,cex = 1.5)
setwd("C:/DeanData/Teaching/EEOB590_AdvBiostat/BioStats/LabData")
#Multivariate Association
library(geomorph)
library(vegan)
library(RRPP)
data(pupfish)
p1<-c(4,10:17, 39:56) #variables [landmarks] in Y1
Y1<-two.d.array(pupfish$coords[p1,,]) # head data as 2D matrix
Y2<-two.d.array(pupfish$coords[-p1,,]) # body data as 2D matrix
Group<-as.factor(paste(pupfish$Pop,pupfish$Sex))
cols <- rep(1, 56)
cols[p1] <- 2
plotAllSpecimens(pupfish$coords, mean = FALSE, plot.param=list(pt.bg = cols)) #to show the data
## 1: Mantel
mantel(dist(Y1),dist(Y2),permutations = 9999)
plot(dist(Y1),dist(Y2))
mantel.partial(dist(Y1),dist(Y2),dist(pupfish$CS))  #3-way Mantel
#2: RV coefficient
RV<-function(x,y,iter=999){
n<-nrow(x)
x<-scale(x,scale=FALSE); y<-scale(y,scale=FALSE)
ind <- c(list(1:n), (Map(function(x) sample.int(n, n), 1:iter)))
y.rand <- lapply(1:(iter+1), function(i) y[ind[[i]], ])
S11<-crossprod(x, x)/(n - 1)
S22<-crossprod(y, y)/(n - 1)
S12.r<-lapply(1:(iter+1), function(i) crossprod(x, y.rand[[i]])/(n - 1))
RV.r<-unlist(lapply(1:(iter+1), function(i) sum(diag(S12.r[[i]]%*%t(S12.r[[i]]))) /
sqrt(sum(diag(S11%*%S11)) * sum(diag(S22%*%S22)))))
p.val<- 1-(rank(RV.r)[1])/(iter+1)
p.val<-ifelse(p.val==0,1/(iter+1),p.val)
return(list(RV=RV.r[[1]],pvalue=p.val))
}
RV(Y1,Y2)
sqrt(RV(Y1,Y2)$RV)  #closer to a correlation
#3: PLS
pls.res<-two.b.pls(Y1,Y2)
summary(pls.res)
plot(pls.res)
# Read Data
mydata<-read.csv("data/Lab-10.Pupfish.csv",header=T)
species<-as.factor(mydata[,1]); sex<-as.factor(mydata[,2])
SL<-(mydata[,3]); Y<-as.matrix(mydata[,-(1:3)])
Group<-as.factor(paste(species,sex))
Y<-prcomp(Y)$x
rdf <- rrpp.data.frame(Y=Y, SL=SL, sex=sex, species=species)
col.gp<-rep("green",nrow(Y));   col.gp[which(species== 'FW')]<-"red"
shape.gp<-rep(21,nrow(Y));   shape.gp[which(sex== 'M')]<-22
plot(Y,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
## CVA
library(MASS)
lda.pupfish<-lda(Y,Group)
cva.pupfish<-predict(lda.pupfish,Y)
cv.scores<-cva.pupfish$x
plot(cv.scores,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
#1: equidistant groups are not represented as such
library(mvtnorm)
corr.val<-0.7
groups<-gl(3,50)
a<- rmvnorm(n=50,mean=c(-3.4,0),sigma=matrix(c(1,corr.val,corr.val,1),2,2))
b<- rmvnorm(n=50,mean=c(3.4,0),sigma=matrix(c(1,corr.val,corr.val,1),2,2))
c<- rmvnorm(n=50,mean=c(0,6),sigma=matrix(c(1,corr.val,corr.val,1),2,2))
orig.data<-rbind(a,b,c)
col.gp.r<-rep("black",nrow(orig.data)); col.gp.r[which(groups== '2')]<-"red"; col.gp.r[which(groups== '3')]<-"green"
plot(orig.data,pch=21,bg=col.gp.r,asp=1,cex=1.5)
ordiellipse(orig.data, groups,conf=0.95)
plot(predict(lda(orig.data,groups))$x,pch=21,bg=col.gp.r,asp=1,cex=1.5)
ordiellipse(predict(lda(orig.data,groups))$x, groups,conf=0.95)
#2: CVA can generate differences even when there are none.
data.rand<-matrix(rnorm(150*150),ncol=150)
plot(data.rand,pch=21,bg=col.gp.r,asp=1,cex=1.5)
plot(predict(lda(data.rand[,1:150],groups))$x,pch=21,bg=col.gp.r,asp=1,cex=1.5)
## RDA
plot(Y,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
pupfish.rda<-rda(Y~SL+species+sex+species:sex)
rda.scores<-predict(pupfish.rda)
plot(rda.scores,pch=shape.gp,bg=col.gp,asp=1,cex=1.5,xlab="RDA 1", ylab="RDA 2")
anova(lm.rrpp(Y~SL*species*sex, data=rdf, print.progress = FALSE))$table
##change X matrix, obtain distinct plots
plot(Y,pch=shape.gp,bg=col.gp,asp=1,cex=1.5)
plot(predict(rda(Y~SL*species*sex)),pch=shape.gp,
bg=col.gp,asp=1,cex=1.5,xlab="RDA 1", ylab="RDA 2")
plot(predict(rda(Y~species*sex)),pch=shape.gp,
bg=col.gp,asp=1,cex=1.5,xlab="RDA 1", ylab="RDA 2")
setwd("C:/DeanData/Teaching/EEOB590_AdvBiostat/BioStats/LabData")
# Read data from Smith and Collyer 2008
snake<-read.csv("data/Lab-11-snake.csv",header=T)
site<-as.factor(snake[,1]);region<-as.factor(snake[,2]);sex<-as.factor(snake[,3])
svl<-snake[,4]; hs<-snake[,5] # hs= head size, calculated as centroid size from lm
Y<-as.matrix(snake[,-(1:5)])
##Setup: Univariate and multivariate models
#Univariate
hs.svl<-lm(hs~svl, model=T,x=T)
hs.sex<-lm(hs~sex, model=T,x=T)
hs.reg<-lm(hs~region, model=T,x=T)
hs.svl.reg<-lm(hs~svl + region, model=T,x=T)
hs.svl.by.reg<-lm(hs~svl*region, model=T,x=T)
hs.svl.sex<-lm(hs~svl + sex, model=T,x=T)
hs.svl.by.sex<-lm(hs~svl*sex, model=T,x=T)
hs.ancova<-lm(hs~svl + sex*region, model=T,x=T)
hs.full<-lm(hs~svl*sex*region, model=T,x=T)
#multivariate
Y.svl<-lm(Y~svl, model=T,x=T)
Y.sex<-lm(Y~sex, model=T,x=T)
Y.reg<-lm(Y~region, model=T,x=T)
Y.svl.reg<-lm(Y~svl+region, model=T,x=T)
Y.svl.by.reg<-lm(Y~svl*region, model=T,x=T)
Y.svl.sex<-lm(Y~svl + sex, model=T,x=T)
Y.svl.by.sex<-lm(Y~svl*sex, model=T,x=T)
Y.mancova<-lm(Y~svl + sex*region, model=T,x=T)
Y.full<-lm(Y~svl*sex*region, model=T,x=T)
#1: Nested Model comparisons:  LRT
anova(hs.full)  #with type I (sequential SS), each term addition is an LRT
anova(hs.svl.reg)
anova(hs.svl,hs.svl.reg)
#Multivariate is the same
anova(Y.full)
anova(Y.svl.reg,Y.svl)
anova(Y.svl.reg,Y.reg)
anova(Y.mancova,Y.svl.reg)  #NOTE: sex not an improvement of model
#2: AIC comparisons
aic.summary<-AIC(hs.svl,hs.sex,hs.reg,hs.svl.reg,hs.svl.by.reg,hs.svl.sex,hs.svl.by.sex,
hs.ancova,hs.full)
aic.summary  #smallest AIC is preferred model
aic.summary  #smallest AIC is prefered model
#Model Averaging
c1<-exp(-.5*0)
c2<-exp(-.5*(AIC(hs.svl.by.reg)-AIC(hs.svl.reg)))
w1<-c1/(c1+c2)  #AIC weights
w2<-c2/(c1+c2)
w1
w2
beta1<-w1*(hs.svl.reg$coef)
beta2<-w2*(hs.svl.by.reg$coef)
beta.avg<-c((beta1[1]+beta2[1]),(beta1[2]+beta2[2]),(beta1[3]+beta2[3]),
(beta1[4]+beta2[4]),beta2[5],beta2[6])
beta.avg #model averaged coefficients
#FIND AIC for averaged model (need likelihood and its parameters)
Terms<-terms(formula(hs.svl.by.reg))  #set up X matrix
X<-model.matrix(Terms)
resid<-hs-X%*%beta.avg
E<-t(resid)%*%resid  #Note: univariate, so this IS the det(E)
n<-nrow(resid); p<-1  #NOTE: p<-ncol(resid) for multivariate
k<-hs.svl.by.reg$rank # same as df in "AIC" except "AIC" adds one for variance
LLik<- (-2*((-.5*n*(log(E/n^p)+p))-(0.5*(n*log(2*pi)))))
pen<-2*(p*k+0.5*p*(p+1))
AIC.mdl.avg<-LLik+pen
AIC(hs.svl.by.reg)
AIC(hs.svl.reg)
AIC.mdl.avg  #NOTE: AIC of average model is WORSE than the 2 input models
#NOTE, these are nested models, so standard LRT is used
anova(hs.svl.reg)
anova(hs.svl.by.reg)
anova(hs.svl.reg,hs.svl.by.reg) # Adding interaction NOT an improvement
#2b: Multivariate model comparison
AIC(Y.svl)  #Need multivariate equivalent (and with correct parameter penalty)
# Multivariate AIC function (from M. Collyer)
maic<-function(x,...){ # each x is a model
y<-resid(x)
E<-t(y)%*%y
d<-det(E)
if(length(E)>1) n<-nrow(y) else n<-length(y)
if(length(E)>1) p<-ncol(y) else p<-1
k<-x$rank # same as df in "AIC" except "AIC" adds one for variance
lh<-n*(log(d/n^p)+p)
LLik<- (-2*((-.5*n*(log(d/n^p)+p))-(0.5*(n*log(2*pi)))))
pen<-2*(p*k+0.5*p*(p+1))
m<-LLik+pen
maic<-c(k,m)
}
maic.svl<-maic(Y.svl)
#NOTE, these are nested models, so standard LRT is used
anova(hs.svl.reg)
anova(hs.svl.by.reg)
anova(hs.svl.reg,hs.svl.by.reg) # Adding interaction NOT an improvement
#2b: Multivariate model comparison
AIC(Y.svl)  #Need multivariate equivalent (and with correct parameter penalty)
# Multivariate AIC function (from M. Collyer)
maic<-function(x,...){ # each x is a model
y<-resid(x)
E<-t(y)%*%y
d<-det(E)
if(length(E)>1) n<-nrow(y) else n<-length(y)
if(length(E)>1) p<-ncol(y) else p<-1
k<-x$rank # same as df in "AIC" except "AIC" adds one for variance
lh<-n*(log(d/n^p)+p)
LLik<- (-2*((-.5*n*(log(d/n^p)+p))-(0.5*(n*log(2*pi)))))
pen<-2*(p*k+0.5*p*(p+1))
m<-LLik+pen
maic<-c(k,m)
}
maic.svl<-maic(Y.svl)
maic.sex<-maic(Y.sex)
maic.reg<-maic(Y.reg)
maic.svl.reg<-maic(Y.svl.reg)
maic.svl.by.reg<-maic(Y.svl.by.reg)
maic.svl.sex<-maic(Y.svl.sex)
maic.svl.by.sex<-maic(Y.svl.by.sex)
maic.mancova<-maic(Y.mancova)
maic.full<-maic(Y.full)
rbind(maic.svl,maic.sex,maic.reg,maic.svl.reg,maic.svl.by.reg,maic.svl.sex,
maic.svl.by.sex,maic.mancova,maic.full)
# Note, maic simplifies to univariate
aic.svl<-maic(hs.svl)
aic.reg<-maic(hs.reg)
aic.svl.reg<-maic(hs.svl.reg)
aic.svl
AIC(hs.svl)
# compare maic to AIC
aic.reg[2]-aic.svl.reg[2] # using maic
AIC(hs.reg)-AIC(hs.svl.reg) # canned R AIC function
##3: Cross validation
x<-seq(1:10)
y<-c(2,2,3,4,4,7,7,7,8,8)
plot(x,y)
anova(lm(y~x))
#subsample, fit model, ersiduals for cross-validated data,
#variance across iterations
iter=1000
rep<-lapply(1:iter, function(j) sample(seq(1:10),5))
diff<-lapply(1:iter, function(j) setdiff(seq(1:10),rep[[j]]))
#full model
model.x<- lapply(1:iter, function(j) lm(y[rep[[j]]]~x[rep[[j]]]))
resid.y<-lapply(1:iter, function(j)  resid(model.x[[j]],newdata=data.frame(c(x[diff[[j]]]))))
ss.x<-unlist(lapply(1:iter, function(j) crossprod(resid.y[[j]])))
#reduced model
model.1<- lapply(1:iter, function(j) lm(y[rep[[j]]]~1))
resid.1<-lapply(1:iter, function(j)  resid(model.1[[j]],newdata=data.frame(c(x[diff[[j]]]))))
ss.1<-unlist(lapply(1:iter, function(j) crossprod(resid.1[[j]])))
c(mean(ss.1),var(ss.1))
c(mean(ss.x),var(ss.x))
rm(list=ls())
#######################
#  Some Clustering Methods
#	NOTE: phylogenetic clustering approaches found in package APE, Phangorn & others
#	  see: 'Analysis of phylogenetic and evolution in R. 2006. E. Paradis
##
#######################
rm(list=ls())
mole.data<-read.csv("Data/Lab-09.Moles.csv",header=T,row.names=1)
mole.dist<-as.dist(mole.data)
### PCoA of mole data
PCoA<-cmdscale(mole.dist)
plot(PCoA,pch=21,bg='black',cex=1.5,asp=1)
text(PCoA[,1]+1.5,PCoA[,2],row.names(mole.data))
#Some clustering methods
mole.single<-hclust(mole.dist,method="single")       #Single-link
mole.complete<-hclust(mole.dist,method="complete")   #Complete-link
mole.upgma<-hclust(mole.dist,method="average")       #UPGMA = average-link
mole.upgmc<-hclust(mole.dist,method="centroid")      #UPGMC
mole.wpgma<-hclust(mole.dist,method="mcquitty")      #WPGMA
mole.wpgmc<-hclust(mole.dist,method="median")        #WPGMC
mole.wards<-hclust(mole.dist,method="ward.D")          #Ward's
##PLOTS
plot(mole.single, hang=-1,lwd=2, main="Single Linkage")
plot(as.dendrogram(mole.single),horiz=TRUE,lwd=4,xlim=c(16,-1), main="Single Linkage")  #single-link
plot(as.dendrogram(mole.complete),horiz=TRUE,lwd=4,xlim=c(16,-1), main="Complete Linkage")  #complete-link
plot(as.dendrogram(mole.upgma),horiz=TRUE,lwd=4,xlim=c(16,-1), main="UPGMA")  #UPGMA
plot(as.dendrogram(mole.wpgma),horiz=TRUE,lwd=4,xlim=c(16,-1), main="WPGMA")  #WPGMA
plot(as.dendrogram(mole.upgmc),horiz=TRUE,lwd=4,xlim=c(16,-1), main="UPGMC")  #UPGMC
plot(as.dendrogram(mole.wpgmc),horiz=TRUE,lwd=4,xlim=c(16,-1), main="WPGMC")  #WPGMC
plot(as.dendrogram(mole.wards),horiz=TRUE,lwd=4,xlim=c(16,-1), main="Ward's")  #Ward's
plot(mole.dist,cophenetic(mole.upgma))  #NOTE that small distances better preserved
#some data (head shape in Plethodon salamanders)
library(geomorph)
data(plethodon)
PC.scores<-prcomp(two.d.array(gpagen(plethodon$land)$coords))$x
plot(PC.scores,pch=21,bg=as.factor(paste(plethodon$species,plethodon$site)),asp=1)
##UPGMA
pleth.dist<-dist(PC.scores)
pleth.upgma<-hclust(pleth.dist,method="average")
plot(as.dendrogram(pleth.upgma),horiz=TRUE,lwd=4, main="UPGMA")  #UPGMA
#PLOT of actual vs. UPGMA distances
plot(pleth.dist,cophenetic(pleth.upgma))
# SAME from PC
plot(pleth.dist,dist(PC.scores[,1:2]))
#K-means
kclusters4<-kmeans(PC.scores,4)
plot(PC.scores[,1:2],col=kclusters4$cluster,, main="K=4")
points(kclusters4$centers, col = 1:4, pch = 8, cex=2)
kclusters3<-kmeans(PC.scores,3)
plot(PC.scores[,1:2],col=kclusters3$cluster, main="K=3")
points(kclusters3$centers, col = 1:3, pch = 8, cex=2)
kclusters2<-kmeans(PC.scores,2)
plot(PC.scores[,1:2],col=kclusters2$cluster, main="K=2")
points(kclusters2$centers, col = 1:2, pch = 8, cex=2)
#compare TESS
TESS<-array(NA,6)
for (i in 1:6){
TESS[i]<-kmeans(PC.scores,i)$tot.withinss
}
plot( TESS)  #seems to bottom out at 3 groups
plot(PC.scores[,1:2],col=kclusters3$cluster, main="K=3")
points(kclusters3$centers, col = 1:3, pch = 8, cex=2)
#######################
#  Some Clustering Methods
#	NOTE: phylogenetic clustering approaches found in package APE, Phangorn & others
#	  see: 'Analysis of phylogenetic and evolution in R. 2006. E. Paradis
##
#######################
rm(list=ls())
?geomorph:::digitize2d
mole.data<-read.csv("Data/Lab-09.Moles.csv",header=T,row.names=1)
View(mole.data)
mole.dist<-as.dist(mole.data)
mole.dist
as.matrix(mole.dist)
class(mole.dist)
class(as.matrix(mole.dist))
### PCoA of mole data
PCoA<-cmdscale(mole.dist)
plot(PCoA,pch=21,bg='black',cex=1.5,asp=1)
text(PCoA[,1]+1.5,PCoA[,2],row.names(mole.data))
plot(PCoA,pch=21,bg='black',cex=1.5,asp=1)
text(PCoA[,1]+1.5,PCoA[,2],row.names(mole.data))
#Some clustering methods
mole.single<-hclust(mole.dist,method="single")       #Single-link
mole.complete<-hclust(mole.dist,method="complete")   #Complete-link
mole.upgma<-hclust(mole.dist,method="average")       #UPGMA = average-link
mole.upgmc<-hclust(mole.dist,method="centroid")      #UPGMC
mole.wpgma<-hclust(mole.dist,method="mcquitty")      #WPGMA
mole.wpgmc<-hclust(mole.dist,method="median")        #WPGMC
mole.wards<-hclust(mole.dist,method="ward.D")          #Ward's
##PLOTS
plot(mole.single, hang=-1,lwd=2, main="Single Linkage")
plot(as.dendrogram(mole.single),horiz=TRUE,lwd=4,xlim=c(16,-1), main="Single Linkage")  #single-link
plot(as.dendrogram(mole.complete),horiz=TRUE,lwd=4,xlim=c(16,-1), main="Complete Linkage")  #complete-link
plot(as.dendrogram(mole.upgma),horiz=TRUE,lwd=4,xlim=c(16,-1), main="UPGMA")  #UPGMA
plot(as.dendrogram(mole.wpgma),horiz=TRUE,lwd=4,xlim=c(16,-1), main="WPGMA")  #WPGMA
plot(as.dendrogram(mole.upgmc),horiz=TRUE,lwd=4,xlim=c(16,-1), main="UPGMC")  #UPGMC
plot(as.dendrogram(mole.wpgmc),horiz=TRUE,lwd=4,xlim=c(16,-1), main="WPGMC")  #WPGMC
plot(as.dendrogram(mole.wards),horiz=TRUE,lwd=4,xlim=c(16,-1), main="Ward's")  #Ward's
?cophenetic
plot(mole.dist,cophenetic(mole.upgma))  #NOTE that small distances better preserved
plot(mole.dist,dist(PCoA[,1:2]))
#some data (head shape in Plethodon salamanders)
library(geomorph)
data(plethodon)
PC.scores<-prcomp(two.d.array(gpagen(plethodon$land)$coords))$x
plot(PC.scores,pch=21,bg=as.factor(paste(plethodon$species,plethodon$site)),asp=1)
plethodon$species
plethodon$site
shape <- two.d.array(gpagen(plethodon$land)$coords)
dim(shape)
View(shape)
?dist
?scale
?vegan:::vegdist
dist2 <- dist(shape)
plot(pleth.dist,dist2)
##UPGMA
pleth.dist<-dist(PC.scores)  #choose your distance
plot(pleth.dist,dist2)
plethdist.13 <-dist(PC.scores[,1:3])
plot(plethdist.13,dist2)
plethdist.1 <-dist(PC.scores[,1])
plot(plethdist.1,dist2)
shape <- two.d.array(gpagen(plethodon$land)$coords) #data prep
PC.scores<-prcomp(shape)$x
plot(PC.scores,pch=21,bg=as.factor(paste(plethodon$species,plethodon$site)),asp=1)
##UPGMA
pleth.dist<-dist(PC.scores)  #choose your distance
pleth.upgma<-hclust(pleth.dist,method="average")
plot(as.dendrogram(pleth.upgma),horiz=TRUE,lwd=4, main="UPGMA")  #UPGMA
#PLOT of actual vs. UPGMA distances
plot(pleth.dist,cophenetic(pleth.upgma))
# SAME from PC
plot(pleth.dist,dist(PC.scores[,1:2]))
#K-means
kclusters4<-kmeans(PC.scores,4)
plot(PC.scores[,1:2],col=kclusters4$cluster,, main="K=4")
points(kclusters4$centers, col = 1:4, pch = 8, cex=2)
#K-means
kclusters4<-kmeans(PC.scores,4)
plot(PC.scores[,1:2],col=kclusters4$cluster,, main="K=4")
kclusters3<-kmeans(PC.scores,3)
plot(PC.scores[,1:2],col=kclusters3$cluster, main="K=3")
kclusters3<-kmeans(PC.scores,3)
plot(PC.scores[,1:2],col=kclusters3$cluster, main="K=3")
kclusters2<-kmeans(PC.scores,2)
plot(PC.scores[,1:2],col=kclusters2$cluster, main="K=2")
#compare TESS
TESS<-array(NA,6)
for (i in 1:6){
TESS[i]<-kmeans(PC.scores,i)$tot.withinss
}
plot( TESS)  #seems to bottom out at 3 groups
#compare TESS
TESS<-array(NA,20)
for (i in 1:20){
TESS[i]<-kmeans(PC.scores,i)$tot.withinss
}
plot( TESS)  #seems to bottom out at 3 groups
#compare TESS
TESS<-array(NA,40)
for (i in 1:40){
TESS[i]<-kmeans(PC.scores,i)$tot.withinss
}
plot( TESS)  #seems to bottom out at 3 groups
TESS
plot(PC.scores[,1:2],col=kclusters3$cluster, main="K=3")
mole.data<-read.csv("Data/Lab-09.Moles.csv",header=T,row.names=1)
mole.dist<-as.dist(mole.data)
### PCoA of mole data
PCoA<-cmdscale(mole.dist)
plot(PCoA,pch=21,bg='black',cex=1.5,asp=1)
text(PCoA[,1]+1.5,PCoA[,2],row.names(mole.data))
#Some clustering methods
mole.single<-hclust(mole.dist,method="single")       #Single-link
mole.complete<-hclust(mole.dist,method="complete")   #Complete-link
mole.upgma<-hclust(mole.dist,method="average")       #UPGMA = average-link
cophenetic(mole.upgma)
?geomorph:::digitize2d
